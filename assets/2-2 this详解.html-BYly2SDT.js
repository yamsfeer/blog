import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,a as t}from"./app-BPFsuHku.js";const p={},o=t(`<h1 id="this详解" tabindex="-1"><a class="header-anchor" href="#this详解"><span>this详解</span></a></h1><h2 id="绑定规则" tabindex="-1"><a class="header-anchor" href="#绑定规则"><span>绑定规则</span></a></h2><h3 id="默认绑定" tabindex="-1"><a class="header-anchor" href="#默认绑定"><span>默认绑定</span></a></h3><p><strong>独立函数调用</strong>作为最常用的函数调用类型，其应用的通常是<strong>默认绑定</strong>。</p><p><strong>当函数不带任何修饰被调用时，会应用默认绑定</strong>。比如<code>fn()</code>。</p><p><strong>默认绑定</strong>是无法应用其他规则时的默认规则。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 默认绑定，this指向全局对象window</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 相当于window.a = 2;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>需要注意的是，<strong>严格模式(strict mode)，那么全局对象将无法使用默认绑定</strong>。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: this is undefined</span>
</code></pre></div><h3 id="隐式绑定" tabindex="-1"><a class="header-anchor" href="#隐式绑定"><span>隐式绑定</span></a></h3><p>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 隐式绑定，foo函数以 obj.foo 形式执行时，this隐式指向上下文对象obj。</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><h4 id="隐式丢失" tabindex="-1"><a class="header-anchor" href="#隐式丢失"><span>隐式丢失</span></a></h4><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// 函数别名!不带任何修饰被调用</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// a 是全局对象的属性</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre></div><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">doFoo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// fn 其实引用的是 foo</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 调用位置!</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// a 是全局对象的属性</span>
<span class="token function">doFoo</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span>foo <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre></div><p><strong>回调函数丢失this是非常常见的</strong>。</p><p>比如<code>setTimeout( obj.foo, 100 )</code>，因为JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似:</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 等待 delay 毫秒</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 调用位置!</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="显式绑定" tabindex="-1"><a class="header-anchor" href="#显式绑定"><span>显式绑定</span></a></h3><h4 id="call-apply" tabindex="-1"><a class="header-anchor" href="#call-apply"><span><strong>call / apply</strong></span></a></h4><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// call / apply 将foo函数的 this 显示地绑定到 obj 上。</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对象，这个原始值会被转换成它的对象形式(也就是new String()、new Boolean()或者 new Number())。</p><p>这通常被称为<strong>装箱</strong>。</p></div><p>call / apply 虽然可以指定一个函数的 this 指向，但是 foo 函数仍可以被作为值传递，引发 <strong>隐式丢失</strong> 的问题（参考上一小节）。</p><p>可以用 <strong>硬绑定</strong> 来强制指定 foo 函数的 this 指向。</p><ul><li><p>硬绑定 <code>bind</code></p><p><strong>硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值</strong></p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 只将bar暴露出去，无法通过bar改变foo的this。</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> obj<span class="token punctuation">,</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span> <span class="token string">&#39;arg&#39;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印 2 arg</span>
</code></pre></div><p>另一个办法是创建一个辅助的 <strong>bind函数</strong>。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 简单的辅助绑定函数</span>
<span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> obj<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token string">&#39;arg&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>由于硬绑定是非常常用的模式，ES5 中提供了内置的方法 <code>Function.prototype.bind</code>，</p><p>bind函数会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token string">&#39;arg&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>指定API调用的上下文</p><p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一 个可选的参数，通常被称为“上下文”(context)，其作用和 bind 一样，确保你的回调函数使用指定的 this。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&quot;id&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 实际上就是通过 call 或者 apply 实现了显式绑定，少写些代码</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> <span class="token comment">/* 把 this 绑定到obj */</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 id 2 id 3 id</span>

<span class="token comment">// 如果不传入obj给forEach，foo函数的this会应用默认绑定，指向window</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> foo <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 undefined 2 undefined 3 undefined</span>
</code></pre></div></li></ul><h3 id="new-绑定" tabindex="-1"><a class="header-anchor" href="#new-绑定"><span>new 绑定</span></a></h3><h4 id="关于new的误解" tabindex="-1"><a class="header-anchor" href="#关于new的误解"><span>关于new的误解</span></a></h4><p><strong>JavaScript 中 new 的机制实际上和面向类的语言完全不同。</strong></p><p>new 操作符后面跟的函数，不是一个类，也不是什么特殊类型的函数，<strong>它只是被 new 操作符调用的普通函数而已</strong>。</p><p><strong>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”</strong>。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>可以认为new操作符是为了模仿传统面向类语言而加入的，JavaScript中只有对象和函数，没有类。</p><p>但是为了便于理解，可以将它们称为类、构造函数。</p></div><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建(或者说构造)一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li><strong>这个新对象会绑定到函数调用的this。</strong></li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol><p>第三步就是所谓的“new 绑定”。</p><h2 id="绑定规则的优先级" tabindex="-1"><a class="header-anchor" href="#绑定规则的优先级"><span>绑定规则的优先级</span></a></h2><p>总结来说就是<strong>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</strong>。</p><ol><li><p>函数是否在new中调用(new绑定)? 如果是的话this绑定的是新创建的对象。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li><li><p>函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是指定的对象。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>
</code></pre></div></li><li><p>函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上下文对象。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li><li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li></ol><p>针对 new绑定 &gt; 显式绑定 可以详细说下。</p><p>MDN 提供的一种bind实现：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>bind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">oThis</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 与 ECMAScript 5 最接近的</span>
      <span class="token comment">// 内部 IsCallable 函数</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span>
        <span class="token string">&quot;Function.prototype.bind - what is trying &quot;</span> <span class="token operator">+</span> <span class="token string">&quot;to be bound is not callable&quot;</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> aArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
        fToBind <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
        <span class="token function-variable function">fNOP</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">fToBind</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
            <span class="token comment">// 判断硬绑定函数是否是被 new 调用，如果是的话就会使用新创建 的 this 替换硬绑定的 this</span>
            <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fNOP</span> <span class="token operator">&amp;&amp;</span> oThis <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> oThis<span class="token punctuation">)</span><span class="token punctuation">,</span>
             aArgs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    fNOP<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fNOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> fBound<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="绑定例外" tabindex="-1"><a class="header-anchor" href="#绑定例外"><span>绑定例外</span></a></h2><p>前面提到，用 <code>call / apply</code> 可以显式绑定一个对象。</p><p>但是把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值</p><p>在调用时会被忽略，实际应用的是<strong>默认绑定规则</strong>。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;a:&quot;</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">&quot;, b:&quot;</span> <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用 bind(..) 进行柯里化</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a:2, b:3</span>
</code></pre></div><p>在上面这个例子中，为了对函数柯里化，需要传入一个参数当作 this 的绑定对象。</p><p>如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择。</p><p>事实上，如果对一些第三方函数柯里化，而这个函数又关心this，就会出现不可预测的结果。</p><p>为此，可以传入一个DMZ”(demilitarized zone，非军事区)对象。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// Object.create(null) 和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”</span>
<span class="token keyword">var</span> <span class="token constant">DMZ</span> <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> <span class="token constant">DMZ</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a:2, b:3</span>
</code></pre></div><h3 id="软绑定" tabindex="-1"><a class="header-anchor" href="#软绑定"><span>软绑定</span></a></h3><p>使用<strong>硬绑定</strong>可以把this强制绑定到指定对象，防止函数调用应用默认绑定规则。</p><p>但是这会大大降低函数的灵活性，<strong>硬绑定后无法使用隐式绑定或者显式绑定来修改 this</strong>。</p><p>如果可以给默认绑定指定一个<strong>全局对象和 undefined 以外</strong>的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>softBind<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">softBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// 捕获所有 curried 参数</span>
    <span class="token keyword">var</span> curried <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> <span class="token function-variable function">bound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>
        <span class="token comment">/* 检查调用时的 this，如果 this 绑定到全局对象或者 undefined，
           那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。 */</span>
        <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> <span class="token punctuation">(</span>window <span class="token operator">||</span> global<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> obj <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">,</span>
        curried<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> curried<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> fn<span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> bound<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>软绑定的例子：</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;name: &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;obj&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;obj2&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    obj3 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;obj3&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> fooOBJ <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">softBind</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fooOBJ</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name: obj</span>

obj2<span class="token punctuation">.</span>foo <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">softBind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj2<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name: obj2 &lt;---- 看!!!</span>

<span class="token function">fooOBJ</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj3 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name: obj3 &lt;---- 看!</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span> obj2<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// name: obj &lt;---- 应用了软绑定</span>
</code></pre></div><h3 id="箭头函数与this" tabindex="-1"><a class="header-anchor" href="#箭头函数与this"><span>箭头函数与this</span></a></h3><p><strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this</strong>。</p><p><em>new 操作符也不能改变箭头函数的 this 指向</em>。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//this 继承自 foo()</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">a</span><span class="token operator">:</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo() 内部创建的箭头函数会捕获调用时 foo() 的 this</span>
<span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj2 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, 不是 3, this指向obj1</span>
</code></pre></div><p>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数来否定 this 机制，那你或许应当:</p><ol><li>只使用词法作用域并完全抛弃错误this风格的代码;</li><li>完全采用 this 风格，在必要时使用 bind，尽量避免使用 self = this 和箭头函数。</li></ol><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。</p><p>找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p><ul><li>由new调用?绑定到新创建的对象。</li><li>由call或者apply(或者bind)调用?绑定到指定的对象。</li><li>由上下文对象调用?绑定到那个上下文对象。</li><li>默认:在严格模式下绑定到undefined，否则绑定到全局对象。</li></ul><p>一定要注意，有些调用可能在无意中使用默认绑定规则。</p><p>如果想“更安全”地忽略 this 绑 定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。</p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES6 之前代码中的 self = this 机制一样。</p>`,70),c=[o];function e(l,u){return s(),a("div",null,c)}const r=n(p,[["render",e],["__file","2-2 this详解.html.vue"]]),d=JSON.parse('{"path":"/YDKJS/YDKJS(%E4%B8%8A%E5%8D%B7)/2-2%20this%E8%AF%A6%E8%A7%A3.html","title":"this详解","lang":"zh-CN","frontmatter":{"description":"this详解 绑定规则 默认绑定 独立函数调用作为最常用的函数调用类型，其应用的通常是默认绑定。 当函数不带任何修饰被调用时，会应用默认绑定。比如fn()。 默认绑定是无法应用其他规则时的默认规则。 需要注意的是，严格模式(strict mode)，那么全局对象将无法使用默认绑定。 隐式绑定 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 th...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-fe/YDKJS/YDKJS(%E4%B8%8A%E5%8D%B7)/2-2%20this%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"this详解"}],["meta",{"property":"og:description","content":"this详解 绑定规则 默认绑定 独立函数调用作为最常用的函数调用类型，其应用的通常是默认绑定。 当函数不带任何修饰被调用时，会应用默认绑定。比如fn()。 默认绑定是无法应用其他规则时的默认规则。 需要注意的是，严格模式(strict mode)，那么全局对象将无法使用默认绑定。 隐式绑定 当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 th..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T16:21:32.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T16:21:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"this详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T16:21:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"绑定规则","slug":"绑定规则","link":"#绑定规则","children":[{"level":3,"title":"默认绑定","slug":"默认绑定","link":"#默认绑定","children":[]},{"level":3,"title":"隐式绑定","slug":"隐式绑定","link":"#隐式绑定","children":[]},{"level":3,"title":"显式绑定","slug":"显式绑定","link":"#显式绑定","children":[]},{"level":3,"title":"new 绑定","slug":"new-绑定","link":"#new-绑定","children":[]}]},{"level":2,"title":"绑定规则的优先级","slug":"绑定规则的优先级","link":"#绑定规则的优先级","children":[]},{"level":2,"title":"绑定例外","slug":"绑定例外","link":"#绑定例外","children":[{"level":3,"title":"软绑定","slug":"软绑定","link":"#软绑定","children":[]},{"level":3,"title":"箭头函数与this","slug":"箭头函数与this","link":"#箭头函数与this","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1712938892000,"updatedTime":1712938892000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":8.41,"words":2524},"filePathRelative":"YDKJS/YDKJS(上卷)/2-2 this详解.md","localizedDate":"2024年4月12日","autoDesc":true}');export{r as comp,d as data};
