import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o,c as p,b as n,d as e,e as a,a as r}from"./app-BPFsuHku.js";const i={},c=n("h1",{id:"lcp-最大内容绘制",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#lcp-最大内容绘制"},[n("span",null,"LCP 最大内容绘制")])],-1),d=n("p",null,"对开发者来说，测量网页主要内容的加载速度并不容易。",-1),u=n("ul",null,[n("li",null,"load 或 DOMContentLoaded 事件不一定与用户在屏幕上看到的内容相对应"),n("li",null,"FCP 只捕获加载最开始的部分，那可能只是启动画面或加载指示。"),n("li",null,"FMP 和 SI 可以捕获到初始绘制之后的加载，但它们十分复杂且经常出错。")],-1),h={href:"https://www.w3.org/webperf/",target:"_blank",rel:"noopener noreferrer"},g=n("strong",null,"最大元素完成渲染",-1),k=r(`<h2 id="什么是-lcp" tabindex="-1"><a class="header-anchor" href="#什么是-lcp"><span>什么是 LCP</span></a></h2><p>LCP ( Largest Contentful Paint ) 最大内容绘制，从开始加载，到最大的内容在可视区域内变得可见的时间。</p><h3 id="哪些元素在考量范围内" tabindex="-1"><a class="header-anchor" href="#哪些元素在考量范围内"><span>哪些元素在考量范围内</span></a></h3><p>LCP 的最大内容主要考虑<strong>图片和文本</strong>，比如：</p><ul><li>img 图片</li><li>内嵌在 svg 元素内的图片</li><li>video 的封面图</li><li>background image ( 通过 <code>url()</code> 函数加载 )</li><li>包含文本的块级元素</li></ul><p>随着研究的深入，未来可能会添加其他元素，如 svg、video 元素本身。</p><h3 id="如何确定一个元素的大小" tabindex="-1"><a class="header-anchor" href="#如何确定一个元素的大小"><span>如何确定一个元素的大小</span></a></h3><p>元素大小通常指<strong>可视区域内可见的大小</strong>。延伸到可视区域之外、被剪裁、不可见的溢出部分不计入元素大小。</p><ul><li>图片使用原始尺寸和可见尺寸中的较小者。即缩小的图片使用显示尺寸，放大的图像使用原始尺寸。</li><li>文本仅考量文本节点的大小，即包含所有文本节点的最小矩形。</li><li>元素的 padding、margin 或 border 都不在考虑范围内。</li></ul><h3 id="何时报告-lcp" tabindex="-1"><a class="header-anchor" href="#何时报告-lcp"><span>何时报告 LCP</span></a></h3><p>网页通常是分阶段加载的，页面上的最大元素可能会变化。</p><p><strong>每次最大元素变化，浏览器都会报告一次 LCP</strong>。例如，一个文本和图片网页，最初只渲染文本，报告一次，随后图片加载完成，报告第二次。</p><p>注意，只有<strong>渲染完成且可见</strong>的元素才可被视为最大内容元素。加载中的图像 、字体阻塞期的文本等都不算完成渲染。</p><ul><li>动态添加 DOM 元素，且新元素大于先前的最大元素，需要报告。</li><li>当前最大元素从可视区域移除，除非有更大的元素渲染，否则该元素将持续作为最大元素。</li><li>页面 scroll 频繁改变可见区域内容，这期间浏览器不会报告 LCP。</li><li>出于安全考虑，缺少 <code>Timing-Allow-Origin</code> 响应头的跨域图像，渲染时间不会公开，只公开加载时间。</li></ul><h3 id="如何处理元素布局和元素大小改变" tabindex="-1"><a class="header-anchor" href="#如何处理元素布局和元素大小改变"><span>如何处理元素布局和元素大小改变</span></a></h3><p>出于性能考虑，<strong>元素大小和位置改变</strong>不会报告 LCP。</p><p>也就是说，在可视区域外渲染，然后移动到可视区域的不会报告；在可视区域内渲染，然后移出可视区域的只会报告其在可视区域的大小。</p><h2 id="lcp-阈值" tabindex="-1"><a class="header-anchor" href="#lcp-阈值"><span>LCP 阈值</span></a></h2><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/8ZW8LQsagLih1ZZoOmMR.svg" alt="良好的 LCP 值为 2.5 秒，较差的值大于 4.0 秒，两者之间的任何东西都需要改进" width="400" class="img-mid"><h2 id="如何测量-lcp" tabindex="-1"><a class="header-anchor" href="#如何测量-lcp"><span>如何测量 LCP</span></a></h2><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">PerformanceObserver</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">list</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> entry <span class="token keyword">of</span> list<span class="token punctuation">.</span><span class="token function">getEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;LCP&#39;</span><span class="token punctuation">,</span> entry<span class="token punctuation">.</span>startTime<span class="token punctuation">,</span> entry<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">observe</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&#39;largest-contentful-paint&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">buffered</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="如果最大元素并非最重要元素" tabindex="-1"><a class="header-anchor" href="#如果最大元素并非最重要元素"><span>如果最大元素并非最重要元素</span></a></h3>`,22),m={href:"https://wicg.github.io/element-timing/",target:"_blank",rel:"noopener noreferrer"},_=n("h2",{id:"如何改进-lcp",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#如何改进-lcp"},[n("span",null,"如何改进 LCP")])],-1),f=n("p",null,"LCP 主要受四个因素影响：",-1),C=n("ul",null,[n("li",null,"缓慢的服务器响应速度"),n("li",null,"JavaScript 和 CSS 渲染阻塞"),n("li",null,"资源加载时间"),n("li",null,"客户端渲染")],-1),P=n("p",null,"改进 LCP 的方法。",-1),b={href:"https://web.dev/apply-instant-loading-with-prpl",target:"_blank",rel:"noopener noreferrer"},L={href:"https://web.dev/critical-rendering-path/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://web.dev/fast#optimize-your-css",target:"_blank",rel:"noopener noreferrer"},y={href:"https://web.dev/fast#optimize-your-images",target:"_blank",rel:"noopener noreferrer"},E={href:"https://web.dev/fast#optimize-web-fonts",target:"_blank",rel:"noopener noreferrer"},w={href:"https://web.dev/fast#optimize-your-javascript",target:"_blank",rel:"noopener noreferrer"},x={href:"https://web.dev/optimize-lcp/",target:"_blank",rel:"noopener noreferrer"};function B(S,T){const t=l("ExternalLinkIcon");return o(),p("div",null,[c,d,u,n("p",null,[e("根据 "),n("a",h,[e("W3C Web 性能工作组"),a(t)]),e(" 的研究，"),g,e("能更准确地描述页面主要内容加载完毕。")]),k,n("p",null,[e("如果页面上最重要的元素不是最大元素，可以用 "),n("a",m,[e("Element Timing API "),a(t)]),e(" 进行自定义测量。")]),_,f,C,P,n("ul",null,[n("li",null,[n("a",b,[e("使用 PRPL 模式做到即时加载"),a(t)])]),n("li",null,[n("a",L,[e("优化关键渲染路径"),a(t)])]),n("li",null,[n("a",v,[e("优化 CSS"),a(t)])]),n("li",null,[n("a",y,[e("优化图像"),a(t)])]),n("li",null,[n("a",E,[e("优化网页字体"),a(t)])]),n("li",null,[n("a",w,[e("优化 JavaScript"),a(t)]),e("（针对客户端渲染的网站）")])]),n("p",null,[e("深入了解如何改进 LCP 请参阅"),n("a",x,[e("优化 LCP"),a(t)]),e("。")])])}const z=s(i,[["render",B],["__file","LCP.html.vue"]]),D=JSON.parse('{"path":"/%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/LCP.html","title":"LCP 最大内容绘制","lang":"zh-CN","frontmatter":{"description":"LCP 最大内容绘制 对开发者来说，测量网页主要内容的加载速度并不容易。 load 或 DOMContentLoaded 事件不一定与用户在屏幕上看到的内容相对应 FCP 只捕获加载最开始的部分，那可能只是启动画面或加载指示。 FMP 和 SI 可以捕获到初始绘制之后的加载，但它们十分复杂且经常出错。 根据 W3C Web 性能工作组 的研究，最大元素...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-fe/%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/LCP.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"LCP 最大内容绘制"}],["meta",{"property":"og:description","content":"LCP 最大内容绘制 对开发者来说，测量网页主要内容的加载速度并不容易。 load 或 DOMContentLoaded 事件不一定与用户在屏幕上看到的内容相对应 FCP 只捕获加载最开始的部分，那可能只是启动画面或加载指示。 FMP 和 SI 可以捕获到初始绘制之后的加载，但它们十分复杂且经常出错。 根据 W3C Web 性能工作组 的研究，最大元素..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T16:21:32.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T16:21:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LCP 最大内容绘制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T16:21:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"什么是 LCP","slug":"什么是-lcp","link":"#什么是-lcp","children":[{"level":3,"title":"哪些元素在考量范围内","slug":"哪些元素在考量范围内","link":"#哪些元素在考量范围内","children":[]},{"level":3,"title":"如何确定一个元素的大小","slug":"如何确定一个元素的大小","link":"#如何确定一个元素的大小","children":[]},{"level":3,"title":"何时报告 LCP","slug":"何时报告-lcp","link":"#何时报告-lcp","children":[]},{"level":3,"title":"如何处理元素布局和元素大小改变","slug":"如何处理元素布局和元素大小改变","link":"#如何处理元素布局和元素大小改变","children":[]}]},{"level":2,"title":"LCP 阈值","slug":"lcp-阈值","link":"#lcp-阈值","children":[]},{"level":2,"title":"如何测量 LCP","slug":"如何测量-lcp","link":"#如何测量-lcp","children":[{"level":3,"title":"如果最大元素并非最重要元素","slug":"如果最大元素并非最重要元素","link":"#如果最大元素并非最重要元素","children":[]}]},{"level":2,"title":"如何改进 LCP","slug":"如何改进-lcp","link":"#如何改进-lcp","children":[]}],"git":{"createdTime":1712938892000,"updatedTime":1712938892000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":3.36,"words":1007},"filePathRelative":"工程架构/性能优化/LCP.md","localizedDate":"2024年4月12日","autoDesc":true}');export{z as comp,D as data};
