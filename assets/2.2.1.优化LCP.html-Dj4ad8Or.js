import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as l,c,b as a,d as n,e as t,a as e}from"./app-BPFsuHku.js";const r={},u=e('<h1 id="优化lcp" tabindex="-1"><a class="header-anchor" href="#优化lcp"><span>优化LCP</span></a></h1><p>LCP 过高的常见原因有：</p><ul><li>缓慢的服务器响应速度</li><li>阻塞渲染的 JavaScript 和 CSS</li><li>缓慢的资源加载速度</li><li>客户端渲染</li></ul><p>下面针对这 4 点原因，提出优化方法。</p><h2 id="缓慢的服务器响应速度" tabindex="-1"><a class="header-anchor" href="#缓慢的服务器响应速度"><span>缓慢的服务器响应速度</span></a></h2><p>从服务器接收内容的时间越长，浏览器渲染内容的时间自然越长。服务器响应时间可以用 TTFB 衡量。</p><p>优化服务器响应时间，有以下方法：</p><h3 id="优化服务器" tabindex="-1"><a class="header-anchor" href="#优化服务器"><span>优化服务器</span></a></h3><ul><li>减少服务端的耗时操作，改善代码执行效率</li><li>优化 SSR 速度，很多 SSR 框架都有性能指导可以参考</li></ul>',9),i={href:"https://web.dev/overloaded-server/",target:"_blank",rel:"noopener noreferrer"},k=e('<h3 id="使用-cdn" tabindex="-1"><a class="header-anchor" href="#使用-cdn"><span>使用 CDN</span></a></h3><p>内容分发网络 ( CDN ) 通过分布在不同地理位置的服务器，就近为用户提供服务。将资源托管在 CDN 可以减少网络请求时间。</p><h3 id="缓存服务器" tabindex="-1"><a class="header-anchor" href="#缓存服务器"><span>缓存服务器</span></a></h3><p>通过在磁盘上存储 HTML 副本，服务器端缓存可以减少 TTFB 并最大限度地减少资源使用。</p><p>服务器缓存有以下方式：</p><ul><li>配置 nginx 反向代理，充当客户端和服务器之间的缓存服务器</li><li>开启云服务的缓存</li><li>开启 CDN 的缓存</li></ul><h3 id="service-worker-缓存" tabindex="-1"><a class="header-anchor" href="#service-worker-缓存"><span>service worker 缓存</span></a></h3><p>Service Worker 会在浏览器后台运行，并可以拦截来自服务器的请求。</p><p>Service Worker 级别的缓存控制可以缓存部分或全部 HTML，且只会在内容改变时更新缓存。</p>',9),h={href:"https://philipwalton.com/articles/smaller-html-payloads-with-service-workers/",target:"_blank",rel:"noopener noreferrer"},d=e(`<h3 id="preconnect-尽早建立连接" tabindex="-1"><a class="header-anchor" href="#preconnect-尽早建立连接"><span>preconnect 尽早建立连接</span></a></h3><p>使用 preconnect 告知浏览器尽快建立对域名的连接。</p><div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preconnect<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>还可以使用 dns-prefetch 来更快地完成 DNS 查找。</p><div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>尽管原理不同，但对于不支持 preconnect 的浏览器，dns-prefetch 可以作为后备。</p><div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preconnect<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>dns-prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://example.com<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
</code></pre></div>`,7),g={href:"https://web.dev/preconnect-and-dns-prefetch/",target:"_blank",rel:"noopener noreferrer"},m=a("h3",{id:"使用签名交换",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#使用签名交换"},[a("span",null,"使用签名交换")])],-1),v=a("p",null,"签名交换 ( SXG ) 是一种交付机制，通过易于缓存的内容格式提升用户体验。",-1),_=a("p",null,"具体来说， Google 搜索会缓存、预获取 SXG。对于通过 Google 搜索获得流量的网站，SXG 可以是改进 LCP 的重要工具。",-1),f={href:"https://web.dev/signed-exchanges",target:"_blank",rel:"noopener noreferrer"},q=a("h2",{id:"阻塞渲染的-javascript-和-css",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#阻塞渲染的-javascript-和-css"},[a("span",null,"阻塞渲染的 JavaScript 和 CSS")])],-1),b=a("p",null,"浏览器解析 HTML 时，遇到 JavaScript 和 css 都会暂停解析 HTML。css 和 js 都是阻塞渲染的资源，它们会导致 LCP 延迟。",-1),S=a("p",null,"对此，有两个方向解决这个问题：",-1),C=a("ul",null,[a("li",null,"减少阻塞资源体积和个数"),a("li",null,"延迟加载阻塞资源")],-1),x=a("h3",{id:"减小文件体积和个数",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#减小文件体积和个数"},[a("span",null,"减小文件体积和个数")])],-1),w=a("li",null,[a("p",null,"用 webpack 插件对 css 或 js 文件进行混淆压缩，从而减小文件体积。")],-1),y=a("p",null,"将关键的 css 或 js 代码内联在 html 中，可以减少资源请求数。",-1),L={href:"https://github.com/GoogleChromeLabs/critters",target:"_blank",rel:"noopener noreferrer"},E=a("li",null,[a("p",null,"尽量减少 JavaScript 的 polyfill。")],-1),T=e(`<h3 id="延迟加载" tabindex="-1"><a class="header-anchor" href="#延迟加载"><span>延迟加载</span></a></h3><p>Chrome 开发者工具中的代码覆盖率面板查找网页上未使用的 CSS。</p><img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/wjS4NrU5EsJeCuvK0zhn.png" alt="Chrome 开发者工具中的代码覆盖率选项卡" style="zoom:80%;" class="img-mid"><ul><li><p>可以将所有未使用的 CSS 完全删除或移动到另一个样式表。</p></li><li><p>初始渲染时不需要的 CSS，用以下方式延迟加载</p><div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span> <span class="token special-attr"><span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value javascript language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span>rel<span class="token operator">=</span><span class="token string">&#39;stylesheet&#39;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li><li><p>html 支持延迟或异步加载 js</p><div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token comment">&lt;!-- defer属性只适用于外部脚本文件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>a.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">defer</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>b.js<span class="token punctuation">&quot;</span></span> <span class="token attr-name">async</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div></li></ul><h3 id="动态导入" tabindex="-1"><a class="header-anchor" href="#动态导入"><span>动态导入</span></a></h3><p>webpack 插件可以将 js 代码进行拆分，然后按需动态导入。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code>form<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;submit&quot;</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;library.moduleA&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 动态导入</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">module</span> <span class="token operator">=&gt;</span> module<span class="token punctuation">.</span>default<span class="token punctuation">)</span> <span class="token comment">// 使用默认 export</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">someFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token function">handleError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="缓慢的资源加载速度" tabindex="-1"><a class="header-anchor" href="#缓慢的资源加载速度"><span>缓慢的资源加载速度</span></a></h2><p>LCP 的最大元素通常是图片和文本。优化这两种资源 ( 尤其是图片 )可以很好地优化 LCP。</p><h3 id="优化和压缩图像" tabindex="-1"><a class="header-anchor" href="#优化和压缩图像"><span>优化和压缩图像</span></a></h3>`,10),B=a("li",null,"删除与内容无关的图像",-1),P={href:"https://web.dev/use-imagemin-to-compress-images",target:"_blank",rel:"noopener noreferrer"},j=a("li",null,"将图像转换为更新的 JPEG 2000、JPEG XR 或 WebP 格式",-1),J=a("li",null,"使用响应式图像",-1),N=a("li",null,"使用图像 CDN",-1),D={href:"https://web.dev/fast/#optimize-your-images",target:"_blank",rel:"noopener noreferrer"},M=e(`<h3 id="预加载" tabindex="-1"><a class="header-anchor" href="#预加载"><span>预加载</span></a></h3><p>很多种类型的资源都可以预加载，但应该侧重于预加载关键资产，例如字体、首屏图像或视频，以及关键路径 CSS 或 JavaScript。</p><div class="language-html" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>script<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>script.js<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style.css<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>image<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>img.png<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>video<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>vid.webm<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>video/webm<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>font.woff2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>font<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>font/woff2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">crossorigin</span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div>`,3),G={href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/preload",target:"_blank",rel:"noopener noreferrer"},A={href:"https://web.dev/preload-critical-assets/",target:"_blank",rel:"noopener noreferrer"},z=a("h3",{id:"brotli-压缩算法",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#brotli-压缩算法"},[a("span",null,"Brotli 压缩算法")])],-1),H=a("p",null,"诸如 Gzip 和 Brotli 的压缩算法可以显著缩减传输的文本大小。所有浏览器都支持 Gzip，新浏览器基本支持 Brotli，并 Brotli 有更好的压缩效果。",-1),R={href:"https://web.dev/reduce-network-payloads-using-text-compression/",target:"_blank",rel:"noopener noreferrer"},W=e(`<h3 id="资产降级" tabindex="-1"><a class="header-anchor" href="#资产降级"><span>资产降级</span></a></h3><p>根据用户的设备或网络条件使用不同登记的资源。例如，网络低于 4G 时显示图像而不是视频。</p><div class="language-javascript" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>navigator<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>effectiveType <span class="token operator">===</span> <span class="token string">&#39;4g&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载视频</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// 加载图像</span>
<span class="token punctuation">}</span>
</code></pre></div>`,3),F={href:"https://web.dev/adaptive-serving-based-on-network-quality/",target:"_blank",rel:"noopener noreferrer"},I=a("h3",{id:"使用-service-worker-缓存资产",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#使用-service-worker-缓存资产"},[a("span",null,"使用 Service Worker 缓存资产")])],-1),V=a("p",null,"使用 Service Worker 预缓存关键资源可以显著减少资源加载时间，特别是对于使用较弱连接重新加载网页，甚至离线访问的用户。",-1),X={href:"https://web.dev/reliable/",target:"_blank",rel:"noopener noreferrer"},Z=e('<h2 id="客户端渲染" tabindex="-1"><a class="header-anchor" href="#客户端渲染"><span>客户端渲染</span></a></h2><p>React、Vue 使得构建 SPA 变得容易，但它们的源文件通常较大，这会对 LCP 有影响。</p><h3 id="服务端渲染" tabindex="-1"><a class="header-anchor" href="#服务端渲染"><span>服务端渲染</span></a></h3><p>SSR 的原理是，在服务端渲染 HTML，在客户端将 JavaScript 及数据 hydrate 到 DOM 中。</p><p>这个做法可以让页面的主要内容首先在服务器进行渲染，从而改进 LCP。但该做法也有弊端：</p><ul><li>服务器和客户端维护相同的由 JavaScript 渲染的应用，增加复杂性。</li><li>在服务器上执行 JavaScript 渲染 HTML 会增加服务器响应时间，影响 TTFB。</li><li>SSR 的页面在相关 JavaScript 执行完毕之前，页面无法响应用户输入，影响 TTI 。</li></ul><h3 id="预渲染" tabindex="-1"><a class="header-anchor" href="#预渲染"><span>预渲染</span></a></h3><p>预渲染就是，用无头浏览器生成每个路由的静态 HTML 文件，然后将这些文件与 JavaScript 一起发送给客户端。</p><p>预渲染与 SSR 相比，服务器响应时间获得优化，TTI 没有优化。</p>',9),O={href:"https://web.dev/rendering-on-the-web/",target:"_blank",rel:"noopener noreferrer"};function U(K,Q){const s=o("ExternalLinkIcon");return l(),c("div",null,[u,a("p",null,[n("关于服务端优化可以参考 "),a("a",i,[n("Fix an overloaded server"),t(s)]),n("。")]),k,a("p",null,[n("参考："),a("a",h,[n("使用 Service Worker 实现更小的 HTML 负载"),t(s)]),n("。")]),d,a("p",null,[n("参考："),a("a",g,[n("尽早建立网络连接来提高页面感知速度"),t(s)])]),m,v,_,a("p",null,[n("参考："),a("a",f,[n("签名交换"),t(s)]),n("。")]),q,b,S,C,x,a("ul",null,[w,a("li",null,[y,a("p",null,[a("a",L,[n("Critters"),t(s)]),n(" 是一个 webpack 插件，能够内联关键 css 并对其余部分进行懒加载。")])]),E]),T,a("ul",null,[B,a("li",null,[n("使用 "),a("a",P,[n("Imagemin"),t(s)]),n(" 压缩图像")]),j,J,N]),a("p",null,[n("参考："),a("a",D,[n("优化您的图像"),t(s)])]),M,a("p",null,[n("参考："),a("a",G,[n("MDN rel=preload"),t(s)]),n("、"),a("a",A,[n("预加载关键资产"),t(s)])]),z,H,a("p",null,[n("参考："),a("a",R,[n("削减和压缩网络负载"),t(s)])]),W,a("p",null,[n("参考："),a("a",F,[n("基于网络质量的自适应服务"),t(s)])]),I,V,a("p",null,[n("参考："),a("a",X,[n("网络可靠性"),t(s)])]),Z,a("p",null,[n("深入了解 SSR 架构参考"),a("a",O,[n("web中的渲染"),t(s)]),n("。")])])}const aa=p(r,[["render",U],["__file","2.2.1.优化LCP.html.vue"]]),na=JSON.parse('{"path":"/%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.2.1.%E4%BC%98%E5%8C%96LCP.html","title":"优化LCP","lang":"zh-CN","frontmatter":{"description":"优化LCP LCP 过高的常见原因有： 缓慢的服务器响应速度 阻塞渲染的 JavaScript 和 CSS 缓慢的资源加载速度 客户端渲染 下面针对这 4 点原因，提出优化方法。 缓慢的服务器响应速度 从服务器接收内容的时间越长，浏览器渲染内容的时间自然越长。服务器响应时间可以用 TTFB 衡量。 优化服务器响应时间，有以下方法： 优化服务器 减少服务...","head":[["meta",{"property":"og:url","content":"https://yamsfeer.github.io/notes-fe/%E5%B7%A5%E7%A8%8B%E6%9E%B6%E6%9E%84/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2.2.1.%E4%BC%98%E5%8C%96LCP.html"}],["meta",{"property":"og:site_name","content":"yamsfeer"}],["meta",{"property":"og:title","content":"优化LCP"}],["meta",{"property":"og:description","content":"优化LCP LCP 过高的常见原因有： 缓慢的服务器响应速度 阻塞渲染的 JavaScript 和 CSS 缓慢的资源加载速度 客户端渲染 下面针对这 4 点原因，提出优化方法。 缓慢的服务器响应速度 从服务器接收内容的时间越长，浏览器渲染内容的时间自然越长。服务器响应时间可以用 TTFB 衡量。 优化服务器响应时间，有以下方法： 优化服务器 减少服务..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-12T16:21:32.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-12T16:21:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"优化LCP\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-12T16:21:32.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"缓慢的服务器响应速度","slug":"缓慢的服务器响应速度","link":"#缓慢的服务器响应速度","children":[{"level":3,"title":"优化服务器","slug":"优化服务器","link":"#优化服务器","children":[]},{"level":3,"title":"使用 CDN","slug":"使用-cdn","link":"#使用-cdn","children":[]},{"level":3,"title":"缓存服务器","slug":"缓存服务器","link":"#缓存服务器","children":[]},{"level":3,"title":"service worker 缓存","slug":"service-worker-缓存","link":"#service-worker-缓存","children":[]},{"level":3,"title":"preconnect 尽早建立连接","slug":"preconnect-尽早建立连接","link":"#preconnect-尽早建立连接","children":[]},{"level":3,"title":"使用签名交换","slug":"使用签名交换","link":"#使用签名交换","children":[]}]},{"level":2,"title":"阻塞渲染的 JavaScript 和 CSS","slug":"阻塞渲染的-javascript-和-css","link":"#阻塞渲染的-javascript-和-css","children":[{"level":3,"title":"减小文件体积和个数","slug":"减小文件体积和个数","link":"#减小文件体积和个数","children":[]},{"level":3,"title":"延迟加载","slug":"延迟加载","link":"#延迟加载","children":[]},{"level":3,"title":"动态导入","slug":"动态导入","link":"#动态导入","children":[]}]},{"level":2,"title":"缓慢的资源加载速度","slug":"缓慢的资源加载速度","link":"#缓慢的资源加载速度","children":[{"level":3,"title":"优化和压缩图像","slug":"优化和压缩图像","link":"#优化和压缩图像","children":[]},{"level":3,"title":"预加载","slug":"预加载","link":"#预加载","children":[]},{"level":3,"title":"Brotli 压缩算法","slug":"brotli-压缩算法","link":"#brotli-压缩算法","children":[]},{"level":3,"title":"资产降级","slug":"资产降级","link":"#资产降级","children":[]},{"level":3,"title":"使用 Service Worker 缓存资产","slug":"使用-service-worker-缓存资产","link":"#使用-service-worker-缓存资产","children":[]}]},{"level":2,"title":"客户端渲染","slug":"客户端渲染","link":"#客户端渲染","children":[{"level":3,"title":"服务端渲染","slug":"服务端渲染","link":"#服务端渲染","children":[]},{"level":3,"title":"预渲染","slug":"预渲染","link":"#预渲染","children":[]}]}],"git":{"createdTime":1712938892000,"updatedTime":1712938892000,"contributors":[{"name":"yamsfeer","email":"feer.yams@gmail.com","commits":1}]},"readingTime":{"minutes":5.62,"words":1687},"filePathRelative":"工程架构/性能优化/2.2.1.优化LCP.md","localizedDate":"2024年4月12日","autoDesc":true}');export{aa as comp,na as data};
