<template><div><h1 id="promise" tabindex="-1"><a class="header-anchor" href="#promise"><span>Promise</span></a></h1>
<h2 id="什么是-promise" tabindex="-1"><a class="header-anchor" href="#什么是-promise"><span>什么是 promise</span></a></h2>
<h3 id="promise两要素" tabindex="-1"><a class="header-anchor" href="#promise两要素"><span>promise两要素</span></a></h3>
<ul>
<li>
<p>承诺</p>
<p>当你在汉堡店下单后，会得到一张收据，这是汉堡店给你的承诺，它承诺一段时间后给你一个汉堡。等待期间你可以去干些别的事。</p>
<p><em>（ pending 状态的 promise ）</em></p>
</li>
<li>
<p>承诺结果：最终要么得到汉堡，要么没得到汉堡，不变的是每个订单都有个最终的状态。</p>
<p><em>（ promise 的 fulfill 或 reject ）</em></p>
</li>
</ul>
<h3 id="判断是不是-promise" tabindex="-1"><a class="header-anchor" href="#判断是不是-promise"><span>判断是不是 promise</span></a></h3>
<p>如何确定某个值是不是 Promise，或者说，行为方式类似于 promise ?</p>
<p>可通过以下两种方法判断：</p>
<ul>
<li>
<p><code v-pre>p instanceof Promise === true</code></p>
</li>
<li>
<p>用鸭子类型判断，promise 的一大特征就是拥有 then 方法</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>
  p <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
  <span class="token punctuation">(</span><span class="token keyword">typeof</span> p <span class="token operator">===</span> <span class="token string">"object"</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> p <span class="token operator">===</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
  <span class="token keyword">typeof</span> p<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">"function"</span>
<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 假定这是一个thenable!</span>
<span class="token punctuation">}</span>
</code></pre></div></li>
</ul>
<h3 id="promise-resolve" tabindex="-1"><a class="header-anchor" href="#promise-resolve"><span>Promise.resolve</span></a></h3>
<p><code v-pre>Promise.resolve</code> 接收的参数可以分为以下几种情况：</p>
<ul>
<li>
<p>传入立即值，得到用这个值填充的 promise</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span>
</code></pre></div></li>
<li>
<p>传入 promise 对象，直接返回这个 promise</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>

p1 <span class="token operator">===</span> p2 <span class="token comment">// true</span>
</code></pre></div></li>
<li>
<p>传入非 promise 的 thenable 值，就会试图展开这个值，直到提取出一个具体值</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  	<span class="token parameter">val</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 42</span>
    <span class="token parameter">err</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
</code></pre></div></li>
</ul>
<p>由此可见，我们可以通过 <code v-pre>Promise.resolve</code> 保证得到一个 promise。</p>
<h2 id="promise-的三个状态" tabindex="-1"><a class="header-anchor" href="#promise-的三个状态"><span>promise 的三个状态</span></a></h2>
<p>4 个重要术语：pending(等待)、resolve(完成)、fullfill(接受)、reject(拒绝)。</p>
<ul>
<li>promise 只能从 pending 变为 resolved，且只能改变一次。</li>
<li>从 pending 变为 resolved 有两种途径：fullfill 或 reject。</li>
</ul>
<img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/e6c9d24egy1h61pptyrocj20a007cq30.jpg" style="zoom:80%;" />
<p>其中容易引起误解的是resolve。</p>
<p>创建 promise 时处理函数通常命名为 resolve 和 reject，但他们不是对应关系。resolve 表示这个 promise 已经不可更改了。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>事实上，resolve 也可以得到 reject 状态的 promise：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"Oops"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token comment">// ES6 规范将这两个回调命名为 onFulfilled 和 onRjected，</span>
    <span class="token comment">// 所以fulfilled、rejected这两个术语很准确。</span>
    <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Oops"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
</code></pre></div><p>综上，promise 有 pending 和 resolved 两种状态；其中 resolved 有 fullfilled、 rejected 两种可能。</p>
<h2 id="链式调用" tabindex="-1"><a class="header-anchor" href="#链式调用"><span>链式调用</span></a></h2>
<p>下面介绍 promise 在链式调用中的数据传递、先后关系和错误处理。</p>
<h3 id="数据传递" tabindex="-1"><a class="header-anchor" href="#数据传递"><span>数据传递</span></a></h3>
<p>每次调用 then 函数，都会创建并返回一个新的 promise</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span> <span class="token comment">// p0</span>
<span class="token comment">// p1</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>v <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p1 1秒后 resolve</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// p2</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 42</span>
</code></pre></div><h3 id="先后关系" tabindex="-1"><a class="header-anchor" href="#先后关系"><span>先后关系</span></a></h3>
<p>在 then 方法中，如果 fullfill 或 reject 函数返回了新的 promise，需要等这个新 promise 完成</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">ajax</span><span class="token punctuation">(</span> url<span class="token punctuation">,</span> resolve <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://xxx/"</span> <span class="token punctuation">)</span>
  <span class="token comment">// 返回新的promise，需要等待它完成才能得到response2</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res1</span> <span class="token operator">=></span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://xxx/"</span> <span class="token operator">+</span> res1 <span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res2</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> res2 <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="错误处理" tabindex="-1"><a class="header-anchor" href="#错误处理"><span>错误处理</span></a></h3>
<p><strong>错误和异常是基于每个 promise 的</strong>，这意味着可能在链的任意位置捕捉到这样的错误。</p>
<p>抛出错误或调用 reject 函数会使 promise 状态变为 rejected。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/"</span> <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res1</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined，出错!</span>
    <span class="token keyword">return</span> res1 <span class="token comment">// 永远不会到达这里</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 永远不会到达这里</span>
    <span class="token comment">// 上一个promise抛出异常，相当于reject，因此这里的promise会调rejected函数</span>
    <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// 捕捉到来自foo.bar()的错误TypeError</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">msg</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
</code></pre></div><p><strong>在 then 函数中，如果不传入 fullfill 或 reject 处理函数，会有默认的处理函数被传入。</strong></p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">reject</span><span class="token punctuation">(</span> <span class="token string">"Oops"</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reject</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 默认的reject处理函数，如果省略或者传入任何非函数值则会被使用</span>
  <span class="token comment">/*function rejected(err) {
      throw err;
	}*/</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>默认拒绝处理函数只是把错误重新抛出，这最终会使得 p2用同样的错误理由 reject。</p>
<p>从本质上说，这使得错误可以继续沿着 Promise 链传播下去，直到遇到显式定义的 reject 处理函数。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 如果没有传递一个有效的函数，则使用默认的fullfill处理函数</span>
  <span class="token comment">// 把接收到的任何传入值传递给下一个promise</span>
	<span class="token comment">// v => v,</span>
	<span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h3>
<p>总结一下，promise 的流程控制：</p>
<ul>
<li>调用 then 方法会自动创建一个新的 promise</li>
<li>如果处理函数返回一个值或抛出异常，这个 promise 就会 resolve</li>
<li>如果处理函数返回一个 promise，它将会被展开，不管它的决议值是什么，都会成为当前 then 返回的链接 Promise 的决议值。</li>
</ul>
<h2 id="错误处理-1" tabindex="-1"><a class="header-anchor" href="#错误处理-1"><span>错误处理</span></a></h2>
<p>调用 reject 函数、JavaScript 抛出异常都可以使 promise 被 reject。</p>
<p><code v-pre>try-catch</code>语句只能处理同步情况，不能用于处理 promise 的异常。</p>
<p>参考以下代码：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> p0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p1 <span class="token operator">=</span> p0<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token function">fullfilled1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">rejected1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 处理p0的rejct或异常（异常会使promise拒绝）</span>
<span class="token punctuation">)</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token function">fullfilled2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">rejected2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 处理p1的reject或异常</span>
<span class="token punctuation">)</span>
<span class="token comment">// 如果p1,p2都没传入reject处理函数，统一在catch函数处理</span>
<span class="token keyword">var</span> p3 <span class="token operator">=</span> p2<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>handleErrs<span class="token punctuation">)</span>
</code></pre></div><p>可以看出，每个 reject 处理函数处理的都是上一个 promise 的异常或reject。</p>
<p>如果 p1,p2 都没传入 reject 处理函数，根据上节提到的默认 reject 处理函数，整个链式调用中可能出现的异常可以“汇集”到 catch 函数中。</p>
<p>但是仍有两个问题：</p>
<ul>
<li>catch 函数中无法判断是哪个 promise 出错</li>
<li>如果 handleErrs 函数本身有异常，则无法捕获</li>
</ul>
<p>书中没有给出这两个问题的标准处理方法。</p>
<h2 id="异步模式" tabindex="-1"><a class="header-anchor" href="#异步模式"><span>异步模式</span></a></h2>
<h3 id="promise-all" tabindex="-1"><a class="header-anchor" href="#promise-all"><span>Promise.all</span></a></h3>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">let</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// [1, 2]</span>
</code></pre></div><p><code v-pre>Promise.all</code> 接收一个 promise 数组，返回一个主 promise。</p>
<ul>
<li>子 promise 都 resolved，主 promise 才 resolved。</li>
<li>子 promise 有任何 rejected，主 promise 也立即 rejected，并丢弃其余 promise 的结果</li>
<li>主 promise 的 resolve 结果由子 promise 的完成消息组成，与传入时顺序一致 ( 与完成顺序无关 )</li>
</ul>
<h3 id="promise-race" tabindex="-1"><a class="header-anchor" href="#promise-race"><span>Promise.race</span></a></h3>
<ul>
<li>任一个子 promise fullfill，主 promise 就 fullfill</li>
<li>任一个子 Promise reject，主 promise 就 reject</li>
</ul>
<p>Promise.race 的一个例子，超时请求：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 启动foo()</span>
  <span class="token function">timeoutPromise</span><span class="token punctuation">(</span> <span class="token number">3000</span> <span class="token punctuation">)</span> <span class="token comment">// 给它3秒钟</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// foo 3秒内完成</span>
  <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 要么 foo 被拒绝，要么没能够按时完成</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h3>
<ul>
<li>Promise.any：任一 promise 完成</li>
<li>Promise.allSettled：所有的 promise 都 settled ( 无论 fullfilled 或 rejected )</li>
<li>其他 API 如 none、first、last、map 等，没有被纳入标准，因此不具体介绍</li>
</ul>
<h2 id="promise-的局限" tabindex="-1"><a class="header-anchor" href="#promise-的局限"><span>promise 的局限</span></a></h2>
<h3 id="无法判断错误来源" tabindex="-1"><a class="header-anchor" href="#无法判断错误来源"><span>无法判断错误来源</span></a></h3>
<p>很多时候并没有为 Promise 链序列的中间步骤保留的引用，没有这样的引用，你就无法关联错误处理函数来可靠地检查错误。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token comment">// p 指向 .catch( handleErrors )返回的 promise</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token constant">STEP2</span> <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token constant">STEP3</span> <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span> handleErrors <span class="token punctuation">)</span>
<span class="token comment">// 无法判断错误来自哪一步</span>
<span class="token comment">// handleErrors如果出错无法捕获</span>
</code></pre></div><h3 id="只能-fullfill-或-reject-单个值" tabindex="-1"><a class="header-anchor" href="#只能-fullfill-或-reject-单个值"><span>只能 fullfill 或 reject 单个值</span></a></h3>
<p>根据定义，promise 只能在 fullfill 或 reject 中传递一个值。</p>
<p>虽然可以用数组或对象包装起来，但是在 promise 链中每一步进行包装和解包装就十分丑陋和笨重了。</p>
<h3 id="只能-resolve-一次" tabindex="-1"><a class="header-anchor" href="#只能-resolve-一次"><span>只能 resolve 一次</span></a></h3>
<p>Promise 最本质的一个特征是：<strong>promise 只能被决议一次( fullfill 或 reject )</strong>。</p>
<p>在许多异步情况中，你只需要获取一个值一次，但是，还有很多异步的情况适合另一种模式，一种类似于事件或数据流的模式，比如为按钮添加点击事件和后续事件处理。</p>
<h3 id="把回调重构成promise" tabindex="-1"><a class="header-anchor" href="#把回调重构成promise"><span>把回调重构成promise</span></a></h3>
<p>假设有一个基于回调写法的函数 <code v-pre>ajax(url, callback)</code>。</p>
<p>我们可以封装一个基于 promise 的函数来替换他，但是这样不够方便，因为这意味着每遇到一个类似函数都需要重构一遍。</p>
<p>对此，可以写一个工具函数方便重构：</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Promise<span class="token punctuation">.</span>warp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Promise<span class="token punctuation">.</span><span class="token function-variable function">warp</span> <span class="token operator">=</span> <span class="token parameter">fn</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 返回一个包裹函数</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">.</span><span class="token punctuation">.</span>args</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token comment">// 包裹函数返回的是promise</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          err <span class="token operator">?</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将回调函数添加到被包裹函数的参数</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> request <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span> ajax <span class="token punctuation">)</span>
<span class="token function">request</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="无法取消" tabindex="-1"><a class="header-anchor" href="#无法取消"><span>无法取消</span></a></h3>
<p>promise 一旦创建并注册了 fullfill、reject 处理函数，则再也没有办法从外部停止它。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  p<span class="token punctuation">,</span>
  <span class="token function">timeoutPromise</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 即使在超时的情况下也会发生</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>事实上，<strong>我们不应该取消单个的promise</strong>，这违背了未来值的可信任性(外部不变性)。然而，promise 链是一个流程控制的表达，在这个抽象层次上是，取消是合适的。</p>
<p><strong>单个 promise 不应该可取消，但是可取消 promise 链是合理的</strong>。</p>
<h2 id="与回调对比" tabindex="-1"><a class="header-anchor" href="#与回调对比"><span>与回调对比</span></a></h2>
<p>第二章介绍回调的时候，提到了回调函数的<strong>控制反转</strong>造成的信任问题。</p>
<p>这里回顾一下，把一个回调传入工具 foo 时可能出现如下问题:</p>
<ul>
<li>
<p>调用回调过早</p>
</li>
<li>
<p>调用回调过晚(或不被调用)</p>
</li>
<li>
<p>调用回调次数过少或过多</p>
</li>
<li>
<p>未能传递所需的环境和参数</p>
</li>
<li>
<p>吞掉可能出现的错误和异常</p>
</li>
</ul>
<p>Promise 的特性就是专门用来为这些问题提供一个有效的可复用的答案。</p>
<ul>
<li>
<p>调用过早</p>
<p>根据定义，Promise 就不必担心这种问题，因为即使是立即完成的 Promise(类似于 <code v-pre>new Promise(resolve =&gt; resolve(42))</code>)也无法被同步观察到。</p>
<p>也就是说，对一个 Promise 调用 then 的时候，即使这个 Promise 已经 resolve，提供给 then 的回调也总会被异步调用。</p>
</li>
<li>
<p>调用过晚</p>
<p>和前面一点类似，Promise 创建对象调用 resolve 或 reject 时，这个 Promise 的 then 注册的回调就会被自动调度。可以确信，这些回调在下一个异步事件点上一定会被触发。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">"C"</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">"A"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">"B"</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// A B C</span>
<span class="token comment">// "C" 无法打断或抢占 "B"，这是因为 Promise 的运作方式。</span>
</code></pre></div></li>
<li>
<p>回调未调用</p>
<p>没有任何东西(甚至 JavaScript 错误)能阻止 Promise 向你通知它的resolve。</p>
<p>如果你对一个 Promise 注册了一个resolve回调和一个reject回调，那么 Promise 在resolve时总是会调用其中的一个。因此对于Promise来说不存在回调未调用的情况。</p>
</li>
<li>
<p>调用回调次数过少或过多</p>
<p>Promise 只能被resolve一次，所以任何通过 then 注册的每个回调就只会被调用一次。</p>
</li>
<li>
<p>未能传递参数/环境值</p>
<p>Promise在fulfill或reject时可以传递参数。</p>
</li>
<li>
<p>吞掉错误或异常</p>
<p>错误或异常会造成promise的reject从而被注册的reject回调处理，也可以用 p.catch() 处理。</p>
<div class="language-javascript" data-ext="js" data-title="js"><pre v-pre class="language-javascript"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 调用reject或抛出错误，这个promise(p1)会被reject</span>
	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// reject(1);</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token comment">// resolve 回调</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 抛出错误，这个promise(p2)会被reject</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// reject回调</span>
<span class="token punctuation">)</span>
</code></pre></div></li>
</ul>
</div></template>


