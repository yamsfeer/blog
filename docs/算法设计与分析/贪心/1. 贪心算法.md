# 贪心算法

## 算法思想

贪心算法适合于**组合优化问题**，求解过程是**多步判断过程**，最终的判断序列对应于问题的最优解

* **依据某种“短视的”贪心策略判断，策略的好坏决定算法的成败**

* **贪心法必须进行正确性证明**
* 证明贪心法不正确：举反例

贪心算法有**算法简单、时间空间复杂度低**的优势。

### 活动选择问题

有$n$项活动，$s_i$和$f_j$分别为活动$i$的开始和结束时间，在时间不重叠的情况下（一个时间段内只能有一个活动），求最多活动数的集合。

举个例子，有10项活动，它们的开始和结束时间如下表：

|  $i$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $s_i$ |  1   |  3   |  2   |  5   |  4   |  5   |  6   |  8   |  8   |  2   |
| $f_i$ |  4   |  5   |  6   |  7   |  9   |  9   |  10  |  11  |  12  |  13  |

* 策略1：先到先服务（开始时间早的优先）

  按开始时间从小到大排序，从前先后挑选。

  这是个<font color=red>错误策略</font>，反例：

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi84kc0motj312i09o3zg.jpg" alt="image-20200830000059459" style="zoom: 40%;" />

* 策略2：短任务优先（占用时间短的优先）

  排序使得$f_1 - s_1 \le f_2 - s_2 \le \dots \le f_n - s_n$，从前先后挑选。

  这是个<font color=red>错误策略</font>，反例：

  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi84ludqp1j311a09kab1.jpg" alt="image-20200830000228157" style="zoom:40%;" />

* 策略3：结束时间早的优先

  排序使得$f_1 \le f_2 \le \dots \le f_n$，从前先后挑选。

  （<font color=green>正确策略</font>，正确性的证明见后文）

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi842diwj1j317o0icad7.jpg" alt="image-20200829234315889" style="zoom:50%;" />

算法伪代码：

```c
// 算法GreedySelect
n = S.length // 活动集S已根据结束时间排序
A = [1] // 两两相容的最大活动集合A
j = 1
for i from 2 to n
  if (start_i >= finish_j) {
    A.push(i)
    j = i
  }
return A
```

时间复杂度：根据结束时间排序的时间复杂度为$O(nlogn)$，选出活动集合需要$O(n)$，最终的<font color=red>时间复杂度：</font>$O(nlogn)$。

## 贪心法的证明

### 按步骤归纳证明

### 按规模归纳证明

### 装载问题

### 交换论证证明

### 最小延迟调度

## 得不到最优解时

### 找零问题
