# 图解Google V8

## 概述

V8 是 JavaScript 虚拟机的一种，能够编译、解释、执行 JavaScript 代码。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw5s35p8kkj30vq08kwfb.jpg" style="zoom: 60%;" />

下面我们会先介绍 JavaScript 的语言特性。

JavaScript 借鉴了很多语言的特性，比如 C 语言的基本语法、Java 的类型系统和内存管理、Schema 的函数作为一等公民、Self 基于原型的继承机制。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw5t6aynftj30vq0cdta3.jpg" style="zoom:50%;" />

V8 执行 JavaScript 代码的流程如下图：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gw5t6bvnv8j30vq0gs0uk.jpg)

V8 中涉及到了很多技术，比如 JIT（即时编译）、延迟解析、隐藏类、内联缓存等。

除了以上技术，我们还将介绍两个非常重要的特性：**事件循环系统**、**垃圾回收机制**。

## 从宏观视角看V8

### 解释执行、编译执行

解释执行就是先将源代码通过编译转为中间代码，然后直接使用解释器解释执行中间代码，最后直接输出结果。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw5t6a7atij30vq06vaan.jpg" style="zoom:67%;" />

编译执行也是先将源代码转为中间代码，然后将中间代码转为机器代码。

通常编译后得到的机器代码是以二进制文件形式存储的。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gw5t6bclzjj30vq096wf1.jpg)

### V8 执行 JavaScript 的过程

V8 作为 JavaScript 虚拟机的一种，采用的是编译执行和解释执行两种方式，这种混合使用编译器和解释器的技术称为 ***JIT (Just In Time)*** 技术。

这是一种权衡策略，因为这两种方法都各自有自的优缺点。

* 解释执行：启动速度快，执行速度慢

* 编译执行：启动速度慢，执行速度快

完整的 V8 执行 JavaScript 的流程图：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gw5t6bvnv8j30vq0gs0uk.jpg)

V8 启动前，需要准备一些基础环境，包括“堆空间”、”栈空间“、”全局执行上下文“、”全局作用域“、”消息循环系统“、”内置函数“等。

* 全局执行上下文：包含执行过程中的全局信息，比如一些内置函数、全局变量等
* 全局作用域：包含全局变量
* 堆、栈：V8 采用了经典的堆和栈的内存管理模式
* 事件循环系统：包含事件驱动器和事件循环队列，它们不断接受并处理事件

### 跟踪一段实际代码的执行

假设有如下代码保存在文件test.js中。

```javascript
var test = 'GeekTime'
```

这段代码会被转化为 AST，通过 V8 提供的调试工具 D8（Debug for V8），可以查看 AST 的结构：

```shell
d8 --print-ast test.js
```

执行命令后，得到如下 AST 的结构：

```shell
--- AST ---
FUNC at 0
	KIND0
	LITERAL ID 0
	SUSPEND COUNT 0 6 . NAME ""
	INFERRED NAME ""
	DECLS
		VARIABLE (0x7ff0e3022298) (mode = VAR, assigned = true) "test"
	BLOCK NOCOMPLETIONS at -1
		EXPRESSION STATEMENT at 11
			INITat11
				VAR PROXY unallocated (0x7ff0e3022298) (mode = VAR, assigned = true)
				LITERAL "GeekTime"
```

AST 是 源代码的结构化表述，它是个树状结构。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw91ivds6kj30vq0awq3c.jpg" style="zoom: 55%;" />

前面提到，在生成 AST 的同时，还会生成作用域，通过 D8 来查看：

```shell
d8 --print-scopes test.js
```

test.js 的代码声明了一个全局变量，可以看到 test 变量被加入到了全局作用域中。

```shell
Global scope:
global { // (0x7fd974022048) (0, 24)
	// will be compiled
	// 1 stack slots
	// temporary vars:
	TEMPORARY .result;  // (0x7fd9740223c8) local[0]
	// local vars:
	VAR test;  // (0x7fd974022298)
}
```

生成 AST 和作用域后，就可以使用解释器生成字节码了。

```shell
d8 --print-bytecode test.js
```

```shell
[generated bytecode for function:  (0x02f7081d3125 <SharedFunctionInfo>)]
Bytecode length: 18
Parameter count 1
Register count 3
Frame size 24
OSR nesting level: 0
Bytecode Age: 0
         0x2f7081d31aa @    0 : 13 00             LdaConstant [0]
         0x2f7081d31ac @    2 : c2                Star1
         0x2f7081d31ad @    3 : 19 fe f8          Mov <closure>, r2
         0x2f7081d31b0 @    6 : 64 4f 01 f9 02    CallRuntime [DeclareGlobals], r1-r2
         0x2f7081d31b5 @   11 : 13 01             LdaConstant [1]
         0x2f7081d31b7 @   13 : 23 02 00          StaGlobal [2], [0]
         0x2f7081d31ba @   16 : 0e                LdaUndefined
         0x2f7081d31bb @   17 : a8                Return
Constant pool (size = 3)
Handler Table (size = 0)
Source Position Table (size = 0)
```

生成字节码后，解释器会执行这段字节码，如果重复执行了某段代码，监控器会将其标记为热点代码，并提交编译器优化。

D8 可以查看被优化的代码和被反优化的代码。

```shell
d8 --print-opt-source test.js
d8 --print-deopt-stress test.js
```

很明显这段代码过于简单，没有触发 V8 的优化机制。

## JavaScript 的语言特性

### 函数

在 JavaScript 中，函数是“可被调用的对象”。

为了实现函数可调用特性，在 V8 内部，我们会为函数对象添加两个**隐藏属性**，如下图所示。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw91iwb7u2j30vq0f3q48.jpg" style="zoom:67%;" />

name 属性的值是函数名称，如果函数没有设置函数名（匿名函数），则默认的 name 属性值为 anonymous。

code 属性值表示函数代码，以字符串形式存储在内存中。当执行到函数调用语句时，V8 便从函数对象中取出 code 属性值，然后解释执行这段代码。

### 原型链

JavaScript 是基于原型的面向对象语言。面向对象的三大特性：封装、继承、多态。

在 JavaScript 中，封装可用 Proxy 实现，继承使用的是原型链，JavaScript 作为一门动态类型语言，可以说自带多态特性。

### 作用域链

作用域链就是将一个个作用域串起来，实现变量查找的路径。讨论作用域链，实际就是在讨
论按照什么路径查找变量的问题。

JavaScript 中有三种作用域：全局作用域、函数作用域、块作用域。

**全局作用域在 V8 启动过程中就创建了，且一直保存在内存中不会被销毁，直至 V8 退出。 **

**函数作用域在执行该函数时创建，函数执行结束之后，函数作用域随之被销毁**。

JavaScript 采用的是**词法作用域**。

### 类型转换

当运行加法时，V8 会严格根据 ECMAScript 规范来执行操作。规范如下：

1. 把第一个表达式 (AdditiveExpression) 的值赋值给左引用 (lref)。

2. 使用 GetValue(lref) 获取左引用 (lref) 的计算结果，并赋值给左值。

3. 使用 ReturnIfAbrupt(lval)， 如果报错就返回错误。

4. 把第二个表达式 (MultiplicativeExpression) 的值赋值给右引用 (rref)。

5. 使用 GetValue(rref) 获取右引用 (rref) 的计算结果，并赋值给 rval。

6. 使用 ReturnIfAbrupt(rval) 如果报错就返回错误。

7. 使用 ToPrimitive(lval) 获取左值 (lval) 的计算结果，并将其赋值给左原生值 (lprim)。

8. 使用 ToPrimitive(rval) 获取右值 (rval) 的计算结果，并将其赋值给右原生值 (rprim)。

9. 如果 Type(lprim) 和 Type(rprim) 中有一个是 String，则:

   a. 把 ToString(lprim) 的结果赋给左字符串 (lstr);
   b. 把 ToString(rprim) 的结果赋给右字符串 (rstr);
   c. 返回左字符串 (lstr) 和右字符串 (rstr) 拼接的字符串。

10. 把 ToNumber(lprim) 的结果赋给左数字 (lnum)。

11. 把 ToNumber(rprim) 的结果赋给右数字 (rnum)。

12. 返回左数字 (lnum) 和右数字 (rnum) 相加的数值。

通俗地理解，V8 会提供了一个 ToPrimitve 方法，作用是将 a 和 b 转换为原生数据类型，转换流程如下:

1. 先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，那么就使用该值进 行强制类型转换;
2. 如果 valueOf 没有返回原始类型，那么就使用 toString 方法的返回值;
3. 如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的错误。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejd2ptaj31hc0u0wgh.jpg" style="zoom: 33%;" />

## JavaScript 特性与V8 机制

### 惰性解析

所谓惰性解析是指：解析的过程中，如果遇到函数声明，会跳过函数内部的代码，暂不为其生成 AST 和字节码。

惰性解析可以加速 JavaScript 代码的启动速度，如果将所有代码一次性编译完成，会大大增加等待时间和内存占用。

惰性解析在闭包场景中会有问题，为此，V8 引入了预解析器。

当解析时遇到一个函数，预解析器会对该函数做一次快速的预解析，其作用有两个：

* 判断当前函数是否存在语法上的错误
* 检查函数内部是否引用了外部变量，如果引用了，预解析器会将这些变量复制到堆中，在执行到该函数的时候，直接使用堆中的引用。

### 对象属性访问、快属性、慢属性

来看一段代码：

```javascript
function Foo() {
	this[100] = 'test-100'
	this[1] = 'test-1'
	this["B"] = 'bar-B'
	this[50] = 'test-50'
	this[9] = 'test-9'
	this[8] = 'test-8'
	this[3] = 'test-3'
	this[5] = 'test-5'
	this["A"] = 'bar-A'
	this["C"] = 'bar-C'
}
var bar = new Foo()
for(key in bar){
	console.log(`index:${key} value:${bar[key]}`)
}
```

这段代码的输出结果为：

```javascript
index:1 value:test-1
index:3 value:test-3
index:5 value:test-5
index:8 value:test-8
index:9 value:test-9
index:50 value:test-50
index:100 value:test-100
index:B value:bar-B
index:A value:bar-A
index:C value:bar-C
```

观察结果，可以看出：

* 数字属性被最先打印，并且按照数字大小的顺序打印;

* 字符串属性依然是按照代码中顺序打印

ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序排列。**

在这里我们把对象中的数字属性称为**排序属性**，在 V8 中被称为 **elements**，字符串属性就 被称为**常规属性**，在 V8 中被称为 **properties**。

在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个**线性数据结构**分别保存排序属性和常规属性。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejef67fj30vq0nijsu.jpg" style="zoom: 50%;" />

如果执行索引操作，V8 会先从 elements 属性中按照顺序查找，然后再在 properties 属性中查找，这样就完成一次索引操作。

#### 快属性和慢属性

将不同的属性分别保存到 element 和 properties 中，简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如 `obj.prop`，需要先找到 properties ，然后找 prop 属性。

虽然只是一步，但是 JavaScript 中的对象属性访问是非常频繁的，这会影响运行效率。

基于这个原因，V8 采取了一个权衡的策略来加快查找属性效率，这个策略是**将部分常规属性直接存储到对象本身**，称为**对象内属性 (in-object properties)。**

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejdypwaj30vq0dm0tl.jpg" style="zoom:67%;" />

对象内属性的数量是固定的，默认是 10 个，超出的将被保存在 properties 中。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejdh2n5j30vq0ocwgb.jpg" style="zoom:50%;" />

### 隐藏类

为了提升 JavaScript 的运行速度，V8 借鉴了很多特性，比如 JIT 机制、为了提高属性访问速度，引入了隐藏类，为了加速运算引入了内联缓存。

参考以下一段代码：

```c
struct Point {
  int x;
  int y;
}
Point point;
point.x = 100;
point.y = 200;
```

C语言在创建对象前，已经给出了结构体的定义，编译时会将x、y的偏移量写入汇编代码中，访问属性时用偏移量计算会很快。

由于 JavaScript 的对象可以在运行时改变，因此无法确定偏移量，只能根据上文提到的 element、properties 查找。

V8 对每个对象做如下两点假 设:

* 对象创建之后不会添加新属性

* 对象创建之后不会删除属性

V8 会为每个对象创建一个隐藏类（称为 map），对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点:

* 对象中包含的所有属性

* 每个属性相对于对象地址的偏移量

有了隐藏类，V8 访问某个对象中的属性时，就会先去隐藏类中查找该属性的偏移量，就可以直接去内存中取出属性值，而不需要经历一系列的查找过程，这大大提升了 V8 的查找效率。

#### 多个对象共用一个隐藏类

每个对象都有一个 map 属性指向该对象的隐藏类。 如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处:

1. 减少隐藏类的创建次数，也间接加速了代码的执行速度

2. 减少了隐藏类的存储空间。

对象形状相同的条件是：相同的属性名称、属性个数、属性顺序。

如果对象的属性个数（添加或删除）发生改变，就需要另外创建一个隐藏类。

注意，属性的值得类型发生改变**不会**创建新的隐藏类。

```javascript
let point = {};
% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a082022d1>
point.x = 100;
% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a08207a79>
point.y = 200;
% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a08207aa1>

point.y = 'abc'; // 改变值类型不会创建新的隐藏类
% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a08207aa1>
```

因此，为了尽量利用隐藏类，需要：

* 保持对象的属性名称、个数、顺序相同
* 尽量一次性初始化完整对象属性
* 尽量避免使用 delete 方法

### 内联缓存

考虑以下代码：

```javascript
function load(o) { return o.x }
let o = { x: 1, y: 2 }
for(let i = 0; i < 10000; i++) {
  load(o)
}
```

获取 x 属性的过程：查找对象的隐藏类，通过隐藏类获取 x 的偏移量，根据偏移量获取属性值。

这个过程在 load 函数中被反复执行，为了优化这个查找过程，V8 采取了 **内联缓存（Inline Cache），简称 IC **的策略。

#### 什么是内联缓存

IC 会为每个**函数**维护一个**反馈向量（FeedBack Vector）**，反馈向量记录了函数执行过程中的一些**关键的中间数据**：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkuz6cpj31rg0oqtbn.jpg" style="zoom:33%;" />

反馈向量是一个表结构，表的每一项称为一个**插槽（Slot）**，函数执行的中间数据存储在插槽中。

考虑以下代码：

```javascript
function load(o) {
  o.y = 4;
  return o.x;
}
```

这个函数有两个**调用点（CallSite）**，分别为 `o.y` 和 `o.x`，它们访问了对象和属性，V8 会在 load 函数的反馈向量中为每个调用点分配一个 slot。

每个插槽包括了索引 (slot index)、类型 (type)、状态 (state)、隐藏类 (map) 地址、和属性偏移量。

load 函数的反馈向量如下图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkvocqgj31rg0ougoc.jpg" style="zoom: 25%;" />

*(隐藏类（map）地址一样是因为访问的是同一个对象)*

#### 反馈向量的写入过程

有如下代码：

```javascript
function load(o) {
  return o.x
}
```

load 函数转换为字节码：

```assembly
StackCheck # 检查栈是否溢出
LdaNamedProperty a0, [0], [0] # 取出参数 a0 的第一个属性值，放入累加器
Return # 返回累加器的值
```

这里我们重点关注 LdaNamedProperty 这句字节码，它有三个参数。

a0 就是 load 函数的第一个参数；第二个参数 [0] 表示取出对象 a0 的第一个属性值；第三个参数和反馈向量有关，它表示将 LdaNamedProperty 操作的中间数据写入到反馈向量中，方括号中间的 0 表示写入反馈向量的第一个插槽。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkx89doj31rg0fx40a.jpg" style="zoom: 40%;" />

* map 缓存了 o 的隐藏类的地址
* offset 缓存了属性 x 的偏移量;

* type 缓存了操作类型 LOAD。在反馈向量中，访问对象属性值的操作为 LOAD 类型。

type 中，除了 **LOAD 类型**操作，还有**存储 (STORE) **和**函数调用 (CALL) **。

#### STORE 和 CALL

再来看一段代码：

```javascript
function foo() {}
function load(o) {
  o.y = 4
  foo()
  return o.x
}
```

它的字节码如下：

```assembly
StackCheck
LdaSmi [4]
StaNamedProperty a0, [0], [0]
LdaGlobal [1], [2]
Star r0
CallUndefinedReceiver0 r0, [4]
LdaNamedProperty a0, [2], [6]
Return
```

这段字节码的执行过程如下图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkw5q3pj31jd0u0n0r.jpg" style="zoom:33%;" />

其中，`o.y = 4` 对应的字节码是：

```assembly
LdaSmi [4] # 将常数 4 加载到累加器
StaNamedProperty a0, [0], [0] # 将累加器中的值赋给 o.y
```

这是一个**存储 (STORE) 类型**操作，V8 会将操作的中间结果存放到反馈向量中的第一个插槽中。

调用 foo 函数的字节码:

```assembly
LdaGlobal [1], [2] # 加载 foo 函数对象的地址到累加器
Star r0
CallUndefinedReceiver0 r0, [4] # 调用函数
```

LdaGlobal：加载 foo 函数的地址到累加器中，然后将中间结果存入反馈向量第 3 个插槽，这是一个**存储 (STORE) 类型**操作。

CallUndefinedReceive：调用函数，将执行的中间结果存入反馈向量第 5 个插槽中，这是一个**调用 (CALL) 类型**操作。

最后就是返回 o.x，这是一个**加载 (LOAD) 类型**操作。

最终生成的反馈向量如下图所示:

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkws3hoj31rg0k176v.jpg" style="zoom: 25%;" />

有了这张表，下次执行 load 函数时就可以通过偏移量提高运行效率。

#### 多态与超态

通过缓存执行过程中的基础信息，就能提升下次执行函数的效率。但是前提是多次执行时，对象的形状是固定的。如果形状不固定会怎么样呢？

来看一段代码：

```javascript
function load(o) {
  return o.x
}
let o1 = { x: 1 }
let o2 = { x: 1, y: 2 }
for(let i = 0; i < 10000; i++) {
  load(o1)
  load(o2)
}
```

可以看到对象 o1 和 o2 是不一样的，这意味着隐藏类也是不同的。

第一次执行时 load 时，o1 的隐藏类和偏移量会被记录。

再次调用 load 函数时，V8 会取出反馈向量中记录的隐藏类，并和 o2 的隐藏类比较，发现不是一个隐藏类。然后将新的隐藏类也记录在反馈向量中。

这时，第一个 slot 里就包含了两个隐藏类和偏移量：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkxk4ndj31rg0magnr.jpg" style="zoom: 25%;" />

* 一个插槽中只包含 1 个隐藏类，称为**单态 (monomorphic)**
* 一个插槽中包含了 2~4 个隐藏类，称为**多态 (polymorphic)** 
* 一个插槽中超过 4 个隐藏类，称为**超态 (magamorphic)**

很明显**单态的性能优于多态和超态，**所以我们需要稍微避免多态和超态的情况。

要避免多态和超态，就尽量默认所有的对象属性是不变的。比如传入 load 函数的对象的形状要尽量保持一致。

#### 小结

强调一点，虽然隐藏类和 IC 能提升代码的执行速度，但在实际项目中，影响性能的因素非常多。

**找出性能瓶颈才是至关重要的，不需要过度关注微优化，也不需要过度担忧代码是否破坏了隐藏类或者 IC 的机制**。相对于其他的性能瓶颈，它们的影响可能是微不足道的。

## 运行 JavaScript

### 运行时环境

在执行 JavaScript 代码之前，V8 就已经准备好了代码的运行时环境，包括**堆栈、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，消息循环系统**等。

准备好运行时环境之后，V8 才可以执行 JavaScript 代码， 这包括解析源码、生成字节码、解释执行或者编译执行这一系列操作。

对运行时环境有足够的了解，能够帮助我们更好地理 V8 的执行流程。比如事件循环系统可以让你清楚各种回调函数是怎么被执行的，栈空间可以让你了解函数是怎么被调用的，堆空间和栈空间让你了解为什么要有传值和传引用，等等。

### 执行上下文

当 V8 开始执行一段可执行代码时，会生成一个执行上下文，用来维护执行当前代码所需要的变量声明、this 指向等。

执行上下文中主要包含三部分，变量环境、词法环境、this 关键字。

在浏览器的环境中，全局执行上下文中就包括了 window 对象，还有默认指向 window 的 this 关键字，另外还有一些 Web API 函数，诸如 setTimeout、XMLHttpRequest 等内容。

而词法环境中，则包含了使用 let、const 等变量的内容。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejclvjoj31hc0u0tai.jpg" style="zoom: 25%;" />

有一点需要注意，全局作用域和全局执行上下文的关系，一个全局执行上下文中，能存在多个作用域。

```javascript
var x = 5
{
  let y = 2
  const z = 3
}
```

这段代码在执行时，有两个作用域，一个是全局作用域，另一个是块作用域，这些内容都会保存到全局执行上下文中。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejc8t0lj31hc0u0t9j.jpg" style="zoom: 25%;" />

当 V8 调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈结构。

```javascript
var x = 1
function show_x() {
  console.log(x)
}
function bar() {
  show_x()
}
bar()
```

当执行到 show_x 的时候，其栈状态如下图所示:

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejf0cctj31hc0u00u0.jpg" style="zoom: 20%;" />

## 相关基础知识

### 如何运行二进制代码

假设有如下代码：

```c++
// code.cpp
int main() {
  int x = 1;
  int y = 2;
  int z = x + y;
  return z;
}
```

使用 gcc 编译：

```shell
gcc -o proc code.cpp
```

编译后得到名为 proc 的可执行程序。

使用 objdump 命令反编译：

```shell
objdump -d proc
```

得到汇编代码如下：

```assembly
proc:	file format mach-o 64-bit x86-64
Disassembly of section __TEXT,__text:
0000000100003f90 <_main>:
100003f90: 55                          	pushq	%rbp
100003f91: 48 89 e5                    	movq	%rsp, %rbp
100003f94: c7 45 fc 00 00 00 00        	movl	$0, -4(%rbp)
100003f9b: c7 45 f8 01 00 00 00        	movl	$1, -8(%rbp)
100003fa2: c7 45 f4 02 00 00 00        	movl	$2, -12(%rbp)
100003fa9: 8b 45 f8                    	movl	-8(%rbp), %eax
100003fac: 03 45 f4                    	addl	-12(%rbp), %eax
100003faf: 89 45 f0                    	movl	%eax, -16(%rbp)
100003fb2: 8b 45 f0                    	movl	-16(%rbp), %eax
100003fb5: 5d                          	popq	%rbp
100003fb6: c3                          	retq
```

典型的计算机系统的硬件组织结构图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev019jeoj31hc0u0dhq.jpg" style="zoom: 25%;" />

1. 二进制代码装载进内存，将第一条指令的地址写入 PC 寄存器
2. 读取指令：根据 PC 指针，取出指令
3. 分析指令：指令解码器分析指令类型，获取操作数
4. 执行指令：根据指令，通过寄存器、ALU 等进行计算

### 栈如何管理函数调用

执行函数时，函数的参数、内部变量都会依次压入到栈中。举个例子：

```c++
int main() {
  int x = 5;
  int y = 5;
  x = 100;
  int z = x + y;
  return z;
}
```

main 函数执行过程中，栈的变化如下图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzz9xybj31hc0u0di6.jpg" style="zoom: 25%;" />

当一个函数调用另一个函数时：

```c++
int add(num1, num2) {
  int x = num1;
  int y = num2;
  int ret = x + y;
  return ret;
}
int main() {
  int x = 5;
  int y = 6;
  x = 100;
  int z = add(x + y);
  return z;
}
```

调用 add 函数前，栈的状态：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzxh8uwj31hc0u00u1.jpg" style="zoom: 25%;" />

在 add 函数中，我们得到了 add 函数的结果 ret，存放在栈顶：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev01s4o1j31rg0snjuk.jpg" style="zoom: 25%;" />

add 函数执行完毕后，我们需要将栈的状态恢复到 main 函数上次执行时的状态，这个过程叫**恢复现场**。

为了恢复现场，在 main 函数调用 add 函数时，需要将 main 函数的栈顶指针（f92）保存到 ebp 寄存器中，恢复现场时，只需将 ebp 中的值存放到 esp 即可。

恢复现场前：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzztinlj31rg0ptn04.jpg" style="zoom: 25%;" />

恢复现场后：

（注意 esp 的值由 f97 变成了 f92，图里没画出 ebp 寄存器，它的值是 f92）

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev02pzmvj31rg0ptq65.jpg" style="zoom: 25%;" />

这里还有一个问题，在执行 add 函数前，ebp 中是有值的，它的值是调用 main 函数前的栈顶地址（f91）。

为了恢复这个值，通常的方法是在 main 函数中调用 add 函数时，将当前 main 函数的**栈帧指针**保存在栈中：（总的来说，就是寄存器不够，只能挪来挪去。）

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzxvau0j31rg0tago4.jpg" style="zoom: 25%;" />

### 字节码

早期的 V8 是将 JavaScript 代码翻译成 AST 后，直接翻译成未优化的二进制代码执行的。现在的 V8 使用了字节码 + 解释器 + 编译器的方式。这中间的发展历史略过。

不使用字节码有两个问题：

* 编译时间过久，影响启动速度
* 缓存二进制代码会占用更多内存

使用字节码有三个好处：

* 编译生成字节码需要的时间短
* 占用内存不多，缓存字节码会大大降低内存占用
* 屏蔽底层细节，可移植性强

#### 生成字节码

在 V8 中，JavaScript 代码解析成 AST 和作用域信息后，Ignition 解释器会将其转化为字节码，然后同样由 Ignition 解释器执行。

考虑以下代码：

```javascript
function add(x, y) {
  var z = x + y
  return z
}
```

这段代码解析后的 AST 可以通过以下命令查看：

```shell
d8 --print-ast code.js 
```

```shell
[generating bytecode for function: add]
-- - AST-- -
FUNC at 12
KIND0
LITERAL ID 1
SUSPEND COUNT 0
NAME "add"
PARAMS
 .VAR(0x7fa7bf8048e8)(mode = VAR, assigned = false) "x"
 .VAR(0x7fa7bf804990)(mode = VAR, assigned = false) "y"
DECLS
 .VARIABLE(0x7fa7bf8048e8)(mode = VAR, assigned = false) "x"
 .VARIABLE(0x7fa7bf804990)(mode = VAR, assigned = false) "y"
 .VARIABLE(0x7fa7bf804a38)(mode = VAR, assigned = false) "z"
BLOCK NOCOMPLETIONS at - 1
 .EXPRESSION STATEMENT at 31
...INITat31
 . . .VAR PROXY local[0](0x7fa7bf804a38)(mode = VAR, assigned = false) "z" 19 ....ADDat32
 . . . .VAR PROXY parameter[0](0x7fa7bf8048e8)(mode = VAR, assigned = false 21. . . . .VAR PROXY parameter[1](0x7fa7bf804990)(mode = VAR, assigned = false 22.RETURN at 37
 .VAR PROXY local[0](0x7fa7bf804a38)(mode = VAR, assigned = false) "z"
```

AST 用图表示如下：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev00detgj31hc0u0wge.jpg" style="zoom: 25%;" />

add 函数的作用域可以用 `--print-scopes` 打印：

```javascript
Global scope:
function add(x, y) { // (0x7f9ed7849468) (12, 47)
  // will be compiled
  // 1 stack slots
  // local vars:
  VAR y;  // (0x7f9ed7849790) parameter[1], never assigned
  VAR z;  // (0x7f9ed7849838) local[0], never assigned
  VAR x;  // (0x7f9ed78496e8) parameter[0], never assigned
}
```

作用域和实际数据的关系图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev0331pfj31rg0qymz5.jpg" style="zoom: 25%;" />

有了 AST 和作用域，Ignition 解释器可以生成字节码，字节码用`--print-bytecode`查看：

```shell
[generated bytecode for function:  (0x38a0081d3141 <SharedFunctionInfo>)]
Bytecode length: 13
Parameter count 1
Register count 2
Frame size 16
OSR nesting level: 0
Bytecode Age: 0
         0x38a0081d31f6 @    0 : 13 00             LdaConstant [0]
         0x38a0081d31f8 @    2 : c3                Star0 
         0x38a0081d31f9 @    3 : 19 fe f9          Mov <closure>, r1
         0x38a0081d31fc @    6 : 64 4f 01 fa 02    CallRuntime [DeclareGlobals], r0-r1
         0x38a0081d3201 @   11 : 0e                LdaUndefined 
         0x38a0081d3202 @   12 : a8                Return 
Constant pool (size = 1)
Handler Table (size = 0)
Source Position Table (size = 0)
```

字节码便是其中的：

```assembly
LdaConstant [0]
Star0
Mov <closure>, r1
CallRuntime
LdaUndefined
Return
```

#### 执行字节码

解释器就是一个虚拟机，虚拟机有两种，基于栈和基于寄存器。

基于寄存器的解释器架构如下图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzx8dncj31hc0u00u1.jpg" style="zoom: 25%;" />

## 异步编程

### 同步、异步回调函数

回调函数有两种形式，同步回调和异步回调。通常我们需要将回调函数传给一个执行函数。

同步回调和异步回调的最大区别在于：**同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。**

参考以下代码：

```javascript
function handle(name, index){
	console.log(index, name);
}
["water", "goods", "like"].forEach(handle)
```

handle 函数是在 forEach 函数内部执行的，这是同步回调。

```javascript
function foo() {}
setTimeout(foo, 3000)
```

这段代码中，setTimeout 函数执行后会立即返回，3秒后 foo 函数才会被执行，foo 函数是在 setTimeout 函数外被执行的，这是异步回调。

那么 foo 函数具体是在哪里被执行的呢，这里需要介绍事件循环队列。

### 事件循环队列

UI 线程之外有一个队列，待执行的事件会被添加到队列中，而 UI 线程会不断循环地从队列中取出、执行事件。

**UI 线程每次从队列中取出，执行事件的过程称为一个任务。**

整个流程大致如下所示:

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcn8pk22aj31hc0u0gnx.jpg" style="zoom: 40%;" />

这里用 XMLHttpRequest 为例介绍异步回调过程：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcn8os9loj31hc0u0tai.jpg" style="zoom: 35%;" />

1. UI 线程从队列中取出一个任务，该任务是一个下载请求，主线程将任务交给网络线程执行
2. 网络线程接到请求之后，和服务器端建立连接，并发出下载请求;
3. 网络线程不断地收到服务器端传过来的数据
4. 网络线程每次接收到数据，将设置的回调函数和返回的数据信息，如字节数、数据位置等信息封装成一个事件，并将事件放到队列中

除了下载，JavaScript 中获取系统设备信息、文件读取等操作都是以类似的方式实现的。

### 宏任务、微任务

上文介绍了事件循环队列，队列中的任务称为**宏任务**。

**微任务可以看成一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。**

JavaScript 引入微任务的原因主要是宏任务的时间粒度太粗了，无法胜任一些对精度和实时性要求更高的场景，**微任务可以在实时性和效率之间做一个有效的权衡**。

下面主要介绍微任务。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcn8q9j37j31rg0o0772.jpg" style="zoom: 25%;" />

微任务是基于事件循环队列、事件循环、UI 主线程还有堆栈的。基于微任务，又可以延伸出协程、Promise、Generator、await / async 等技术。

#### 主线程、调用栈、事件循环队列

用一个例子来观察主线程、调用栈、事件循环队列三者间的关系。

```javascript
function foo() {
  setTimeout(foo, 0)
}
foo()
```

foo 函数执行前的状态：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddeo24scj31kx0u0gnv.jpg" style="zoom: 33%;" />

执行 foo 函数时，会创建 foo 函数的执行上下文并入栈，然后 setTimeout 会将 foo 函数封装成一个宏任务并入队：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdderrgk5j31rg0tego8.jpg" style="zoom:33%;" />

foo 函数执行结束后，当前的宏任务也就结束了，调用栈也会被清空。一个宏任务结束后，继续执行队列中的其他任务，直到某一刻轮到 setTimeout 函数创建的宏任务：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddeoeomyj31rg0tl40p.jpg" style="zoom:33%;" />

最后，foo 函数再次被执行。这个过程会一直循环下去，但由于每次宏任务都使 “foo 函数执行上下文” 出栈，因此不会栈溢出。

#### 微任务

微任务会在当前的任务快要执行结束时执行。微任务可以比较精准地控制回调函数的执行时机。

在函数内部触发的微任务，一定比在函数内部触发的宏任务要优先执行。

来看一段代码：

```javascript
function foo() {
  console.log('foo')
  Promise.resolve().then(
  	() => console.log('micro-foo')
  )
  setTimeout(() => console.log('macro-foo'), 0)
  bar();
}
function bar() {
  console.log('bar')
  Promise.resolve().then(
  	() => console.log('micro-bar')
  )
  setTimeout(() => console.log('macro-bar'), 0)
}

foo()
console.log('global')
Promise.resolve().then(
	() => console.log('micro-global')
)
setTimeout(() => console.log('macro-global'), 0)
```

执行结果：

```javascript
foo
bar
global
micro-foo
micro-bar
micro-global
macro-foo
macro-bar
macro-global
```

初始状态下，调用栈中包含全局执行上下文，微任务队列为空：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddera1zvj31mj0u00wl.jpg" style="zoom: 33%;" />

调用 foo 函数，会创建微任务 micro-foo 和 宏任务 macro-foo，微任务进入微任务队列，宏任务进入事件循环队列。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddepub29j31l90u0q76.jpg" style="zoom:33%;" />

foo 函数调用 bar 函数，bar 函数中创建了微任务 micro-bar 和 宏任务 macro-bar。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddeqepfdj31ks0u0n1m.jpg" style="zoom:33%;" />

接下来，bar 函数执行完毕退出，bar 函数的执行上下文出栈，紧接着 foo 函数也结束，foo 函数的上下文也出栈。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddeqz73qj31nf0u0gps.jpg" style="zoom:33%;" />

foo 函数执行完毕后，会执行全局环境的代码，这里会创建微任务 micro-global 和 宏任务 macro-global。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddeoyh4sj31ny0u00x7.jpg" style="zoom:33%;" />

然后重点来了，此时需要销毁全局执行上下文，在销毁之前，需要依次执行微任务队列中的任务，即 micro-foo、micro-bar、micro-global。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddes9rngj31o00u0dkp.jpg" style="zoom:33%;" />

微任务队列清空后，当前宏任务也要结束了，然后依次执行宏任务 macro-foo、macro-bar、macro-global。全部执行完毕后的状态：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwddepgtisj31mj0u0ta9.jpg" style="zoom: 33%;" />

#### 微任务中触发新的微任务

考虑以下代码：

```javascript
function foo() {
  return Promise.resolve().then(foo)
}
foo()
```

这段代码中，foo 函数会创建微任务 foo，每次 foo 函数执行完之前会执行微任务，又会继续创建微任务。如此循环，当前宏任务便无法退出，意味着其他宏任务无法执行，比如鼠标、键盘事件，页面无法响应事件。

### 异步编程范式

异步编程方案的演变可以用下图表示：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdli9uec2j31hc0u0jsq.jpg" style="zoom:33%;" />

总的来说：

* 回调函数有回调地狱和函数控制权转移的问题
* promise 虽然符合线性思路，但是流程复杂时，promise 会充满 then 方法，语义不明显
* generator 函数可以暂停函数执行，等异步返回了结果再恢复执行
* async / await 则改进了生成器的缺点，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力

#### 生成器 generator

其中值得一说的是，生成器函数是如何实现函数的暂停和恢复执行的。

答案就是协程。**协程是一种比线程更轻量级的存在**。

可以认为协程是跑在线程上的任务。一个线程可以存在多个协程，但是线程同时只能执行一个协程。

最重要的是，协程不是被操作系统内核管理，而完全是由程序控制(用户态执行)。这样的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

来看一段代码：

```javascript
function* getResult() {
	yield 'getUserID'
	yield 'getUserName'
	return 'name'
}
let result = getResult()

console.log(result.next().value)
console.log(result.next().value)
console.log(result.next().value)
```



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdlia80dbj31rg0svade.jpg" style="zoom:33%;" />

#### async / await

其实 async/await 背后就是 Promise 和生成器。往底层说，就是微任务和协程应用。

根据 MDN 定义，async 是一个通过**异步执行并隐式返回 Promise** 作为结果的函数。

简单地理解，如果在 async 函数里面使用了 await， 那么此时 async 函数就会暂停执行，并等待合适的时机来恢复执行，所以说 async 是一个异步执行的函数。

通常，await 可以等待两种类型的表达式:

* 可以是任何普通表达式
* 也可以是一个 Promise 对象的表达式

async 是一个可以暂停和恢复执行的函数，我们会在 async 函数内部使用 await 来暂停 async 函数的执行，await 等待的是一个 Promise 对象，如果 Promise 的状态变成 resolve 或者 reject，那么 async 函数会恢复执行。

## 垃圾回收

垃圾回收过程可以分为以下三步：

第一步，通过 GC Root 标记空间中的活动对象和非活动对象。

V8 采用**可访问性（reachability）算法**判断堆中对象是否为活动对象。具体地说，这个算法是将一些 **GC Root** 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历能到达的所有对象。

* 通过 GC Root 能到达的对象就是**可访问的（reachable）**，称为**活动对象**。
* 通过 GC Root 不能到达的就是**不可访问的（unreachable）**，称为**非活动对象**

在浏览器环境中，GC Root 有很多，比如 window 对象、document 对象（DOM 树）等。

第二步，回收非活动对象占据的内存。

就是在标记完成之后，统一清理内存中的非活动对象。具体的清理过程后面会介绍。

第三步，内存整理。

一般来说，频繁回收对象后，内存中会存在大量不连续空间，称为**内存碎片**。如果需要分配较大的连续内存，可能出现内存不足的情况，因此需要整理内存。（有的垃圾回收器不会产生内存碎片，比如接下来介绍的副垃圾回收器。）

### 代际假说

代际假说是垃圾回收领域中一个重要的术语，它有以下两个特点:

* 大部分对象都是“朝生夕死”的

  大部分对象存活的时间很短，比如函数内部声明的变量、块级作用域中的变量。函数或代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问。

* 不死的对象会活得更久，比如全局的 window、DOM、Web API 等对象。

这两个特点不仅仅适用于 JavaScript，同样适用于 Java、 Python 等。

V8 的垃圾回收策略，就是建立在该假说的基础之上的。

### 老生代、新生代

V8 把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，通常只支持 1~8M 的容量；老生代中存放生存时间久的对象，容量比新生代大得多。


目前 V8 采用了两个垃圾回收器：

* **主垃圾回收器 Major GC**，负责老生代的垃圾回收
* **副垃圾回收器 Minor GC**，负责新生代的垃圾回收

### 副垃圾回收器

通常小对象会被分配到新生代，所以新生代的垃圾回收比较频繁。

副垃圾回收器用 **Scavenge 算法**。就是把新生代空间**对半划分**为**对象区域 (from-space)**和**空闲区域 (to-space)**。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwab0z9lj31hc0u0gnq.jpg" style="zoom:25%;" />

新对象会被放入对象区，对象区快被写满时，会进行一次垃圾回收操作。

垃圾回收过程：

1. 标记：将对象区中的**活动对象、非活动对象**做标记
2. 复制：把**活动对象**复制到空闲区
3. 内存整理：同时把这些对象有序地排列起来
4. 角色互换：对象区和空闲区角色互换
5. 对象晋升：经过两次垃圾回收依然存活的对象晋升为老生代

标记、复制、内存整理过程示意图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwabg73nj31hc0u0t9y.jpg" style="zoom:25%;" />

角色转换：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwabziqej31hc0u0abb.jpg" style="zoom:25%;" />

### 主垃圾回收器

主垃圾回收器主要负责老生代中的垃圾回收。除了从新生代晋升的对象，大的对象会直接分配到老生代里。因此，老生代中的对象有两个特点：**占用空间大**、**存活时间长**。

采用 Scavenge 算法清除老生代对象效率不高，还会浪费一半空间。所以主回收器采用**标记 - 整理(Mark-Compact)**算法。

1. 标记：对老生代中的**活动对象、非活动对象**做标记
2. 整理、清除：将所有活动对象整理到一端，清理之外的内存。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwacjv5fj31rg0s575d.jpg" style="zoom:25%;" />

（之前的算法是**标记-清除(Mark-Sweep)**，即标记后直接清除垃圾内存，这样会产生内存碎片，因此后来采用了标记-整理算法。）

### 优化垃圾回收效率

JavaScript 是运行在主线程上的。因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复执行。这叫做**全停顿(Stop-The-World)**。

如果垃圾回收执行的时间太久或过于频繁，会造成页面的卡顿。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa7t011j31rg0jpq4a.jpg" style="zoom:25%;" />

为了解决这个问题，V8 团队经过了多年努力，提出了**并行、并发和增量**等垃圾回收技术。

总的来说，它们主要是从两方面来解决效率问题的：

* **将一个完整的垃圾回收任务拆分成多个小任务**，这样就消灭了单个时间长的任务;

* **将标记对象、移动对象等任务转移到后台线程进行**，这会大大减少主线程暂停的 时间。

#### 并行回收

所谓并行回收，是指垃圾回收器开启多个协助线程，**同时执行同样的回收工作**。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa9l1emj31rg0m1gnc.jpg" style="zoom:25%;" />

副垃圾回收器采用的就是并行策略。

它在垃圾回收过程中，启动了多个线程负责新生代的垃圾清理操作。这些线程同时进行数据移动操作。由于数据的地址发生了改变，还需要同步更新引用这些对象的指针。

虽然并行策略能增加垃圾回收的效率，能够很好地优化副垃圾回收器，但是这**仍然是一种全 停顿**的垃圾回收方式。

#### 增量回收

所谓增量垃圾回收，是指将标记工作分解为更小的块，并且在主线程穿插执行。

采用增量垃圾回收时，没有必要一次执行完整的垃圾回收，每次执行的只是整个过程中的一小部分，

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa92nlhj31rg0jnt9x.jpg" style="zoom:25%;" />

增量标记的算法，比全停顿的算法复杂，主要因为**增量回收是并发的 (concurrent)**，要实现增量执行，需要满足两点要求:

1. 垃圾回收可以随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了才能继续启动。
1. 暂停期间，被标记好的垃圾如果被 JavaScript 代码修改了，垃圾回收器需要能够正确地处理。

先来看第一点，如何实现垃圾回收的暂停和重启。

为了解决这个问题，V8 采用了**三色标记法**，即黑白灰三色。

1. 黑色：该节点被 GC Root 引用到，而且该节点的子节点都已标记完成。
2. 灰色：该节点被 GC Root 引用到，但子节点还没被标记，表明正在处理这个节点。
3. 白色：没有被引用或还没被访问到

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa87n3pj31hc0u0gne.jpg" style="zoom:25%;" />

根据当前是否有灰色节点，可以判断整个标记是否完成。如果没有灰节点，可以进行清理工作（清除白色节点）；如果有灰节点，当下次恢复垃圾回收器时，便从灰节点开始继续执行。

再来看第二点，如果标记好的垃圾数据被 JavaScript 修改了，如何处理。

来看个例子：

```javascript
window.a = {}
window.a.b = {}
window.a.b.c = {}
```

这段代码执行完后，启动了一次垃圾回收，很明显它们都会被标记为黑色。

此时，执行了如下代码：

```javascript
window.a.b = {}
```

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwaa0wxmj31rg0lbq4b.jpg" style="zoom:25%;" />

当 b 节点被标记为黑色后被续上一个白节点（d 还没被访问过），垃圾回收器不会再将这个白节点标记为黑节点了，因为这个路径已经遍历过了。

解决办法是：**不让黑色节点指向白色节点**。

也就是说，每当黑节点指向白节点，强制将白节点变成灰节点。

这个方法也被称为**强三色不变性**，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时，所有白节点对于垃圾回收器来说，都是不可到达的，可以安全释放。

#### 并发回收

虽然**三色标记法**可以很好地实现增量回收，但是这些操作都是在主线程上执行的，当主线程繁忙时，增量回收操作依然会增加降低主线程处理任务的**吞吐量 (throughput)**。

所谓并发回收，是指主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwaakhaij31ki0u0wgc.jpg" style="zoom:25%;" />

并发回收是三种技术中最难的一种，它主要有两个问题：
* 主线程执行 JavaScript 时，堆中内容随时有可能变化，这会使辅助线程的工作无效。
* 主线程和辅助线程极有可能在同一时间更改同一对象，需要锁来解决

尽管并行回收要额外解决以上两个问题，但是权衡利弊，并行回收这种方式的效率还是远高
于其他方式的。

V8 的主垃圾回收器融合了这三种机制，示意图如下：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa8ozpvj31q00u0mzs.jpg" style="zoom:25%;" />

* 并发标记。在主线程执行 JavaScript，辅助线程就开始执行标记操作了。

* 并行清理。主线程在执行清理操作时，辅助线程也在执行清理操作。

* 增量标记的方式。清理的任务会穿插在各种 JavaScript 任务之间执行。

整个过程中，辅助线程进行标记，且采用增量标记的方式，这样既不阻塞主线程，也不会一次标记太多使得整理过程耗时过长；当主线程进行整理时（阻塞），辅助线程帮助整理，加快速度。

总结就是，辅助线程独立增量标记，帮忙主线程整理。

## 几种内存问题

内存问题可以定义为下面这三类:

### 内存泄漏 (Memory leak)

内存泄露是指内存占用越来越大，它会导致页面的性能越来越差。

通常是因为没有对不需要的资源进行回收。下面举三个例子：

1. 全局变量

   ```javascript
   // window
   function foo() {
     arr = Array(10000); // 相当于 this.arr = Array(10000)
   }
   ```

   无意中，临时变量变成全局变量，window 指向 arr 使得不能被垃圾回收。

2. 闭包引用

   ```javascript
   function foo() {
     let obj = {
       x: Array(10000),
       y: 1
     }
     return function () {
       // 为了访问 obj.y，闭包会保持对 obj 的引用
       console.log(obj.y)
     }
   }
   ```

   解决办法：

   ```javascript
   function foo() {
     let obj = {
       x: Array(10000),
       y: 1
     }
     let closure = obj.y // 消除闭包对 obj.x 的引用
     return function () {
       console.log(closure)
     }
   }
   ```

3. detached dom 节点

   只有同时满足 DOM 树和 JavaScript 代码都不引用某个 DOM 节点，该节点才会被作为垃圾进行回收。

   如果某个节点已从 DOM 树移除，但 JavaScript 仍然引用它，此节点称为“**detached** ”节点。“**detached ”**节点是 DOM 内存泄漏的常见原因。

   ```javascript
   let detachedTree
   function createTree() {
     let ul = document.createElement('ul')
     for (let i = 0; i < 1000; i++) {
       ul.appendChild(document.createElement('li'))
     }
     detachedTree = ul
   }
   createTree()
   ```

   Dom 节点将 ul 移除后，detachedTree 仍保留对它的引用，无法被回收。

### 内存膨胀 (Memory bloat)

内存膨胀和内存泄漏有一些差异，内存膨胀主要表现在对内存管理的不科学，可能是没有充分地利用好缓存，也有可能加载了一些不必要的资源。通常表现为内存在某一段时间内快速增长，然后达到一个平稳的峰值继续运行。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwdx96vx7nj31rg0q9q4b.jpg)

要避免内存膨胀，需要充分利用缓存等，减轻项目中不必要的内存占用。

### 频繁垃圾回收

频繁使用大的临时变量，导致新生代空间很快被装满，从而频繁触发垃圾回收。

频繁的垃圾回收操作会让你感觉到页面卡顿。

```javascript
function repeatFun() {
  let arr = Array(10000)
  console.log(arr)
}

for(let i = 0; i < 100000; i++) {
  repeatFun();
}
```

可以考虑将 Array(10000) 设置为全局变量。
