# 对象访问和函数执行

## 函数惰性解析

解析过程中，如果遇到函数声明，会跳过函数内部的代码，暂不为其生成 AST 和字节码。

惰性解析可以加速启动速度，如果将所有代码一次性编译完成，会大大增加等待时间和内存占用。

然而，惰性解析在闭包场景中会有问题，为此，V8 引入了预解析器。

当解析时遇到一个函数，预解析器会对该函数做一次快速的预解析，其作用有两个：

* 判断是否存在语法上的错误
* 检查函数内部是否引用了外部变量，如果引用了，预解析器会将这些变量复制到堆中，当执行到该函数的时候，直接使用堆中的引用。

## 对象属性访问

来看一段代码：

```javascript
function Foo() {
	this[100] = 'test-100'
	this[1] = 'test-1'
	this["B"] = 'bar-B'
	this[50] = 'test-50'
	this[9] = 'test-9'
	this[8] = 'test-8'
	this[3] = 'test-3'
	this[5] = 'test-5'
	this["A"] = 'bar-A'
	this["C"] = 'bar-C'
}

var bar = new Foo()
for(key in bar){
  console.log(`index:${key} value:${bar[key]}`)
}
```

这段代码的输出结果为：

```javascript
index:1 value:test-1
index:3 value:test-3
index:5 value:test-5
index:8 value:test-8
index:9 value:test-9
index:50 value:test-50
index:100 value:test-100
index:B value:bar-B
index:A value:bar-A
index:C value:bar-C
```

观察结果，可以看出：

* 数字属性被先打印，且按照数字大小打印

* 字符串属性按代码中顺序打印

ECMAScript 规范中定义了**数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序排列。**

V8 把对象中的数字属性称为**排序属性** ( **elements** )，字符串属性称为**常规属性** ( **properties** )。

为了有效提升存储和访问的性能，V8 内部分别使用了两个**线性数据结构**保存 elements 和 properties。

<img class="img-mid" src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejef67fj30vq0nijsu.jpg" style="zoom: 50%;" />

如果执行索引操作，V8 会先从 elements 属性中按照顺序查找，然后再在 properties 属性中查找，这样就完成一次索引操作。

## 快属性、慢属性

将不同的属性分别保存到 element 和 properties 中，简化了程序的复杂度，但是在查找元素时，却多了一步操作，比如 `obj.prop`，需要先找到 properties ，然后找 prop 属性。

虽然只是一步，但是 JavaScript 中的对象属性访问是非常频繁的，这会影响运行效率。

对此 V8 的策略是：**将部分 properties 直接存储到对象本身**，称为**对象内属性 ( in-object properties )**。

<img class="img-mid" src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejdypwaj30vq0dm0tl.jpg" style="zoom:67%;" />

对象内属性的数量是固定的，默认是 10 个，超出的将被保存在 properties 中。

<img class="img-mid" src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejdh2n5j30vq0ocwgb.jpg" style="zoom:50%;" />

## 隐藏类 ( hidden class )

参考以下代码：

```c
struct Point {
  int x;
  int y;
}
Point point;
point.x = 100;
point.y = 200;
```

C语言在创建对象前，已经给出了结构体的定义，编译时会将 x、y 的偏移量写入汇编代码中，访问属性时用偏移量计算会很快。

JavaScript 对象可以在运行时改变，无法确定偏移量，只能根据 element、properties 查找。

V8 对每个对象做了两点假设:

* 创建之后不会添加新属性
* 创建之后不会删除属性

V8 为每个对象创建一个隐藏类 ( map )，map 中记录了:

* 对象的所有属性
* 每个属性相对于对象地址的偏移量

每个对象都有一个 map 属性指向该对象的隐藏类。

```javascript
let point = { x: 100, y: 200 }
```

<img class="img-mid" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h66elj1c06j20v00j4ta2.jpg" style="zoom:40%;" />

有了隐藏类，V8 访问对象属性时，就会先去隐藏类中查找该属性的偏移量，然后在内存中取出属性值，而不需要经历一系列的查找过程，大大提升了查找效率。

### 多个对象共用隐藏类

 如果两个对象形状相同 ( 属性名称、个数、顺序相同 )，V8 就会复用同一个隐藏类。

```javascript
let point = { x: 100, y: 200 }
let point2 = { x: 3, y: 4 }
```

<img class="img-mid" src="https://tva1.sinaimg.cn/large/e6c9d24egy1h66eznnz7pj20ny0i4gm8.jpg" alt="image-20220914203809619" style="zoom:50%;" />

如果两个对象不满足形状相同，就需要另外创建一个隐藏类。

如果对象在运行过程中改变，也会重新创建隐藏类。

*( 属性值的类型改变不会创建新的隐藏类 )*

```javascript
let point = {};

% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a082022d1>
point.x = 100;
% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a08207a79>
point.y = 200;
% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a08207aa1>

point.y = 'abc'; // 改变值类型不会创建新的隐藏类
% DebugPrint(point); // 0x2c2a080499ad <Object map = 0x2c2a08207aa1>
```

因此，为了尽量利用隐藏类，需要：

* 保持对象的属性名称、个数、顺序相同
* 一次性初始化完整对象属性
* 避免使用 delete 方法

## 内联缓存 ( Inline Cache )

考虑以下代码：

```javascript
const obj = { x: 1, y: 2 }
const load = obj => obj.x

while(i++ < 10000) {
  load(obj)
}
```

获取 x 属性的过程：查找对象的隐藏类，通过隐藏类获取 x 的偏移量，根据偏移量获取属性值。

这个过程会反复执行，为了优化这个过程，V8 采取了 **内联缓存 ( Inline Cache )** 的策略。

### 什么是内联缓存

内联缓存会为每个**函数**维护一个**反馈向量 ( FeedBack Vector )**，反馈向量记录了函数执行过程中的一些**关键的中间数据**：

<img class="img-mid" src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkuz6cpj31rg0oqtbn.jpg" style="zoom:33%;" />

反馈向量是一个表结构，表的每一项称为一个**插槽 ( Slot )**，函数执行的中间数据存储在插槽中。

考虑以下代码：

```javascript
function load(o) {
  o.y = 4;
  return o.x;
}
```

这个函数有两个**调用点 ( CallSite )**，分别为 `o.y` 和 `o.x`，它们访问了对象和属性，V8 会在 load 函数的反馈向量中为每个调用点分配一个 slot。

每个插槽包括了索引 ( index )、类型 ( type )、状态 ( state )、隐藏类 ( map )、属性偏移量 ( offset )。

load 函数的反馈向量如下图：

<img class="img-mid" src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkvocqgj31rg0ougoc.jpg" style="zoom: 25%;" />

*(隐藏类 ( map ) 地址一样是因为访问的是同一个对象)*

### 反馈向量的写入过程

有如下代码：

```javascript
function load(o) {
  return o.x
}
```

load 函数转换为字节码：

```assembly
StackCheck # 检查栈是否溢出
LdaNamedProperty a0, [0], [0] # 取出参数 a0 的第一个属性值，放入累加器
Return # 返回累加器的值
```

这里我们重点关注 LdaNamedProperty 这句字节码，它有三个参数。

* 参数1：a0 就是 load 函数的第一个参数
* 参数2：[0] 表示取出对象 a0 的第一个属性值
* 参数3：和反馈向量有关，它表示将 LdaNamedProperty 操作的中间数据写入到反馈向量中，方括号中间的 0 表示写入反馈向量的第一个插槽。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkx89doj31rg0fx40a.jpg" style="zoom: 40%;" />

* map 缓存了 o 的隐藏类的地址
* offset 缓存了属性 x 的偏移量;
* type 缓存了操作类型 LOAD。在反馈向量中，访问对象属性值的操作为 LOAD 类型。

type 中，除了 **LOAD** 操作，还有**存储 ( STORE )** 和**函数调用 ( CALL )**。

### STORE 和 CALL

再来看一段代码：

```javascript
function foo() {}
function load(o) {
  o.y = 4
  foo()
  return o.x
}
```

它的字节码如下：

```assembly
StackCheck
LdaSmi [4]
StaNamedProperty a0, [0], [0]
LdaGlobal [1], [2]
Star r0
CallUndefinedReceiver0 r0, [4]
LdaNamedProperty a0, [2], [6]
Return
```

这段字节码的执行过程如下图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkw5q3pj31jd0u0n0r.jpg" style="zoom:33%;" />

其中，`o.y = 4` 对应的字节码是：

```assembly
LdaSmi [4] # 将常数 4 加载到累加器
StaNamedProperty a0, [0], [0] # 将累加器中的值赋给 o.y
```

这是一个**存储 (STORE) 类型**操作，V8 会将操作的中间结果存放到反馈向量中的第一个插槽中。

调用 foo 函数的字节码:

```assembly
LdaGlobal [1], [2] # 加载 foo 函数对象的地址到累加器
Star r0
CallUndefinedReceiver0 r0, [4] # 调用函数
```

LdaGlobal：加载 foo 函数的地址到累加器中，然后将中间结果存入反馈向量第 3 个插槽，这是一个**存储 (STORE) 类型**操作。

CallUndefinedReceive：调用函数，将执行的中间结果存入反馈向量第 5 个插槽中，这是一个**调用 (CALL) 类型**操作。

最后就是返回 o.x，这是一个**加载 (LOAD) 类型**操作。

最终生成的反馈向量如下图所示:

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkws3hoj31rg0k176v.jpg" style="zoom: 25%;" />

有了这张表，下次执行 load 函数时就可以通过偏移量提高运行效率。

### 多态与超态

通过缓存执行过程中的基础信息，就能提升下次执行函数的效率。但是前提是多次执行时，对象的形状是固定的。如果形状不固定会怎么样呢？

来看一段代码：

```javascript
function load(o) {
  return o.x
}
let o1 = { x: 1 }
let o2 = { x: 1, y: 2 }
for(let i = 0; i < 10000; i++) {
  load(o1)
  load(o2)
}
```

可以看到对象 o1 和 o2 是不一样的，这意味着隐藏类也是不同的。

第一次执行时 load 时，o1 的隐藏类和偏移量会被记录。

再次调用 load 函数时，V8 会取出反馈向量中记录的隐藏类，并和 o2 的隐藏类比较，发现不是一个隐藏类。然后将新的隐藏类也记录在反馈向量中。

这时，第一个 slot 里就包含了两个隐藏类和偏移量：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwcfkxk4ndj31rg0magnr.jpg" style="zoom: 25%;" />

* 一个插槽中只包含 1 个隐藏类，称为**单态 (monomorphic)**
* 一个插槽中包含了 2~4 个隐藏类，称为**多态 (polymorphic)**
* 一个插槽中超过 4 个隐藏类，称为**超态 (magamorphic)**

很明显**单态的性能优于多态和超态，**所以我们需要稍微避免多态和超态的情况。

要避免多态和超态，就尽量默认所有的对象属性是不变的。比如传入 load 函数的对象的形状要尽量保持一致。

### 小结

强调一点，虽然隐藏类和 IC 能提升代码的执行速度，但在实际项目中，影响性能的因素非常多。

**找出性能瓶颈才是至关重要的，不需要过度关注微优化，也不需要过度担忧代码是否破坏了隐藏类或者 IC 的机制**。相对于其他的性能瓶颈，它们的影响可能是微不足道的。

## 总结

为了提升 JavaScript 的运行速度，V8 借鉴了很多特性，比如 JIT 机制、为了提高属性访问速度，引入了隐藏类，为了加速运算引入了内联缓存。
