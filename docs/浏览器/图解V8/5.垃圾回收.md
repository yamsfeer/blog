# 垃圾回收

垃圾回收过程可以分为以下三步：

第一步，通过 GC Root 标记空间中的活动对象和非活动对象。

V8 采用**可访问性（reachability）算法**判断堆中对象是否为活动对象。具体地说，这个算法是将一些 **GC Root** 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历能到达的所有对象。

* 通过 GC Root 能到达的对象就是**可访问的（reachable）**，称为**活动对象**。
* 通过 GC Root 不能到达的就是**不可访问的（unreachable）**，称为**非活动对象**

在浏览器环境中，GC Root 有很多，比如 window 对象、document 对象（DOM 树）等。

第二步，回收非活动对象占据的内存。

就是在标记完成之后，统一清理内存中的非活动对象。具体的清理过程后面会介绍。

第三步，内存整理。

一般来说，频繁回收对象后，内存中会存在大量不连续空间，称为**内存碎片**。如果需要分配较大的连续内存，可能出现内存不足的情况，因此需要整理内存。（有的垃圾回收器不会产生内存碎片，比如接下来介绍的副垃圾回收器。）

## 代际假说

代际假说是垃圾回收领域中一个重要的术语，它有以下两个特点:

* 大部分对象都是“朝生夕死”的

  大部分对象存活的时间很短，比如函数内部声明的变量、块级作用域中的变量。函数或代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问。

* 不死的对象会活得更久，比如全局的 window、DOM、Web API 等对象。

这两个特点不仅仅适用于 JavaScript，同样适用于 Java、 Python 等。

V8 的垃圾回收策略，就是建立在该假说的基础之上的。

## 老生代、新生代

V8 把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，通常只支持 1~8M 的容量；老生代中存放生存时间久的对象，容量比新生代大得多。


目前 V8 采用了两个垃圾回收器：

* **主垃圾回收器 Major GC**，负责老生代的垃圾回收
* **副垃圾回收器 Minor GC**，负责新生代的垃圾回收

## 副垃圾回收器

通常小对象会被分配到新生代，所以新生代的垃圾回收比较频繁。

副垃圾回收器用 **Scavenge 算法**。就是把新生代空间**对半划分**为**对象区域 (from-space)**和**空闲区域 (to-space)**。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwab0z9lj31hc0u0gnq.jpg" style="zoom:25%;" />

新对象会被放入对象区，对象区快被写满时，会进行一次垃圾回收操作。

垃圾回收过程：

1. 标记：将对象区中的**活动对象、非活动对象**做标记
2. 复制：把**活动对象**复制到空闲区
3. 内存整理：同时把这些对象有序地排列起来
4. 角色互换：对象区和空闲区角色互换
5. 对象晋升：经过两次垃圾回收依然存活的对象晋升为老生代

标记、复制、内存整理过程示意图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwabg73nj31hc0u0t9y.jpg" style="zoom:25%;" />

角色转换：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwabziqej31hc0u0abb.jpg" style="zoom:25%;" />

## 主垃圾回收器

主垃圾回收器主要负责老生代中的垃圾回收。除了从新生代晋升的对象，大的对象会直接分配到老生代里。因此，老生代中的对象有两个特点：**占用空间大**、**存活时间长**。

采用 Scavenge 算法清除老生代对象效率不高，还会浪费一半空间。所以主回收器采用**标记 - 整理(Mark-Compact)**算法。

1. 标记：对老生代中的**活动对象、非活动对象**做标记
2. 整理、清除：将所有活动对象整理到一端，清理之外的内存。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwacjv5fj31rg0s575d.jpg" style="zoom:25%;" />

（之前的算法是**标记-清除(Mark-Sweep)**，即标记后直接清除垃圾内存，这样会产生内存碎片，因此后来采用了标记-整理算法。）

## 优化垃圾回收效率

JavaScript 是运行在主线程上的。因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复执行。这叫做**全停顿(Stop-The-World)**。

如果垃圾回收执行的时间太久或过于频繁，会造成页面的卡顿。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa7t011j31rg0jpq4a.jpg" style="zoom:25%;" />

为了解决这个问题，V8 团队经过了多年努力，提出了**并行、并发和增量**等垃圾回收技术。

总的来说，它们主要是从两方面来解决效率问题的：

* **将一个完整的垃圾回收任务拆分成多个小任务**，这样就消灭了单个时间长的任务;

* **将标记对象、移动对象等任务转移到后台线程进行**，这会大大减少主线程暂停的 时间。

### 并行回收

所谓并行回收，是指垃圾回收器开启多个协助线程，**同时执行同样的回收工作**。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa9l1emj31rg0m1gnc.jpg" style="zoom:25%;" />

副垃圾回收器采用的就是并行策略。

它在垃圾回收过程中，启动了多个线程负责新生代的垃圾清理操作。这些线程同时进行数据移动操作。由于数据的地址发生了改变，还需要同步更新引用这些对象的指针。

虽然并行策略能增加垃圾回收的效率，能够很好地优化副垃圾回收器，但是这**仍然是一种全 停顿**的垃圾回收方式。

### 增量回收

所谓增量垃圾回收，是指将标记工作分解为更小的块，并且在主线程穿插执行。

采用增量垃圾回收时，没有必要一次执行完整的垃圾回收，每次执行的只是整个过程中的一小部分，

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa92nlhj31rg0jnt9x.jpg" style="zoom:25%;" />

增量标记的算法，比全停顿的算法复杂，主要因为**增量回收是并发的 (concurrent)**，要实现增量执行，需要满足两点要求:

1. 垃圾回收可以随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了才能继续启动。
1. 暂停期间，被标记好的垃圾如果被 JavaScript 代码修改了，垃圾回收器需要能够正确地处理。

先来看第一点，如何实现垃圾回收的暂停和重启。

为了解决这个问题，V8 采用了**三色标记法**，即黑白灰三色。

1. 黑色：该节点被 GC Root 引用到，而且该节点的子节点都已标记完成。
2. 灰色：该节点被 GC Root 引用到，但子节点还没被标记，表明正在处理这个节点。
3. 白色：没有被引用或还没被访问到

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa87n3pj31hc0u0gne.jpg" style="zoom:25%;" />

根据当前是否有灰色节点，可以判断整个标记是否完成。如果没有灰节点，可以进行清理工作（清除白色节点）；如果有灰节点，当下次恢复垃圾回收器时，便从灰节点开始继续执行。

再来看第二点，如果标记好的垃圾数据被 JavaScript 修改了，如何处理。

来看个例子：

```javascript
window.a = {}
window.a.b = {}
window.a.b.c = {}
```

这段代码执行完后，启动了一次垃圾回收，很明显它们都会被标记为黑色。

此时，执行了如下代码：

```javascript
window.a.b = {}
```

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwaa0wxmj31rg0lbq4b.jpg" style="zoom:25%;" />

当 b 节点被标记为黑色后被续上一个白节点（d 还没被访问过），垃圾回收器不会再将这个白节点标记为黑节点了，因为这个路径已经遍历过了。

解决办法是：**不让黑色节点指向白色节点**。

也就是说，每当黑节点指向白节点，强制将白节点变成灰节点。

这个方法也被称为**强三色不变性**，它保证了垃圾回收器能够正确地回收数据，因为在标记结束时，所有白节点对于垃圾回收器来说，都是不可到达的，可以安全释放。

### 并发回收

虽然**三色标记法**可以很好地实现增量回收，但是这些操作都是在主线程上执行的，当主线程繁忙时，增量回收操作依然会增加降低主线程处理任务的**吞吐量 (throughput)**。

所谓并发回收，是指主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwaakhaij31ki0u0wgc.jpg" style="zoom:25%;" />

并发回收是三种技术中最难的一种，它主要有两个问题：
* 主线程执行 JavaScript 时，堆中内容随时有可能变化，这会使辅助线程的工作无效。
* 主线程和辅助线程极有可能在同一时间更改同一对象，需要锁来解决

尽管并行回收要额外解决以上两个问题，但是权衡利弊，并行回收这种方式的效率还是远高
于其他方式的。

V8 的主垃圾回收器融合了这三种机制，示意图如下：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwdwa8ozpvj31q00u0mzs.jpg" style="zoom:25%;" />

* 并发标记。在主线程执行 JavaScript，辅助线程就开始执行标记操作了。

* 并行清理。主线程在执行清理操作时，辅助线程也在执行清理操作。

* 增量标记的方式。清理的任务会穿插在各种 JavaScript 任务之间执行。

整个过程中，辅助线程进行标记，且采用增量标记的方式，这样既不阻塞主线程，也不会一次标记太多使得整理过程耗时过长；当主线程进行整理时（阻塞），辅助线程帮助整理，加快速度。

总结就是，辅助线程独立增量标记，帮忙主线程整理。

## 几种内存问题

内存问题可以定义为下面这三类:

### 内存泄漏 (Memory leak)

内存泄露是指内存占用越来越大，它会导致页面的性能越来越差。

通常是因为没有对不需要的资源进行回收。下面举三个例子：

1. 全局变量

   ```javascript
   // window
   function foo() {
     arr = Array(10000); // 相当于 this.arr = Array(10000)
   }
   ```

   无意中，临时变量变成全局变量，window 指向 arr 使得不能被垃圾回收。

2. 闭包引用

   ```javascript
   function foo() {
     let obj = {
       x: Array(10000),
       y: 1
     }
     return function () {
       // 为了访问 obj.y，闭包会保持对 obj 的引用
       console.log(obj.y)
     }
   }
   ```

   解决办法：

   ```javascript
   function foo() {
     let obj = {
       x: Array(10000),
       y: 1
     }
     let closure = obj.y // 消除闭包对 obj.x 的引用
     return function () {
       console.log(closure)
     }
   }
   ```

3. detached dom 节点

   只有同时满足 DOM 树和 JavaScript 代码都不引用某个 DOM 节点，该节点才会被作为垃圾进行回收。

   如果某个节点已从 DOM 树移除，但 JavaScript 仍然引用它，此节点称为“**detached** ”节点。“**detached ”**节点是 DOM 内存泄漏的常见原因。

   ```javascript
   let detachedTree
   function createTree() {
     let ul = document.createElement('ul')
     for (let i = 0; i < 1000; i++) {
       ul.appendChild(document.createElement('li'))
     }
     detachedTree = ul
   }
   createTree()
   ```

   Dom 节点将 ul 移除后，detachedTree 仍保留对它的引用，无法被回收。

### 内存膨胀 (Memory bloat)

内存膨胀和内存泄漏有一些差异，内存膨胀主要表现在对内存管理的不科学，可能是没有充分地利用好缓存，也有可能加载了一些不必要的资源。通常表现为内存在某一段时间内快速增长，然后达到一个平稳的峰值继续运行。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwdx96vx7nj31rg0q9q4b.jpg)

要避免内存膨胀，需要充分利用缓存等，减轻项目中不必要的内存占用。

### 频繁垃圾回收

频繁使用大的临时变量，导致新生代空间很快被装满，从而频繁触发垃圾回收。

频繁的垃圾回收操作会让你感觉到页面卡顿。

```javascript
function repeatFun() {
  let arr = Array(10000)
  console.log(arr)
}

for(let i = 0; i < 100000; i++) {
  repeatFun();
}
```

可以考虑将 Array(10000) 设置为全局变量。
