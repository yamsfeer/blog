# 运行时环境

在执行 JavaScript 代码之前，V8 就已经准备好了代码的运行时环境，包括**堆栈、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，消息循环系统**等。

准备好运行时环境之后，V8 才可以执行 JavaScript 代码， 这包括解析源码、生成字节码、解释执行或者编译执行等一系列操作。

对运行时环境有足够的了解，能够帮助我们更好地理解 V8 的执行流程。

* 事件循环系统可以让你清楚各种回调函数是怎么被执行的
* 栈空间可以让你了解函数是怎么被调用的
* 堆空间和栈空间让你了解为什么要有传值和传引用，等等

## 执行上下文

当 V8 开始执行一段可执行代码时，会生成一个执行上下文，用来维护执行当前代码所需要的变量声明、this 指向等。

执行上下文中主要包含三部分：

* 变量环境
* 词法环境
* this 关键字

在浏览器环境中，全局执行上下文包括：

* window 对象
* 默认指向 window 的 this 关键字
* Web API 函数，如 setTimeout、XMLHttpRequest 等

而词法环境中，则包含了使用 let、const 等变量的内容。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejclvjoj31hc0u0tai.jpg" style="zoom: 25%;" />

有一点需要注意，全局作用域和全局执行上下文的关系，一个全局执行上下文中，能存在多个作用域。

```javascript
var x = 5
{
  let y = 2
  const z = 3
}
```

这段代码在执行时，有两个作用域，一个是全局作用域，另一个是块作用域，这些内容都会保存到全局执行上下文中。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejc8t0lj31hc0u0t9j.jpg" style="zoom: 25%;" />

当 V8 调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈结构。

```javascript
var x = 1
function show_x() {
  console.log(x)
}
function bar() {
  show_x()
}
bar()
```

当执行到 show_x 的时候，其栈状态如下图所示:

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwaejf0cctj31hc0u00u0.jpg" style="zoom: 20%;" />

## 相关基础知识

### 如何运行二进制代码

假设有如下代码：

```c++
// code.cpp
int main() {
  int x = 1;
  int y = 2;
  int z = x + y;
  return z;
}
```

使用 gcc 编译：

```shell
gcc -o proc code.cpp
```

编译后得到名为 proc 的可执行程序。

使用 objdump 命令反编译：

```shell
objdump -d proc
```

得到汇编代码如下：

```assembly
proc:	file format mach-o 64-bit x86-64
Disassembly of section __TEXT,__text:
0000000100003f90 <_main>:
100003f90: 55                          	pushq	%rbp
100003f91: 48 89 e5                    	movq	%rsp, %rbp
100003f94: c7 45 fc 00 00 00 00        	movl	$0, -4(%rbp)
100003f9b: c7 45 f8 01 00 00 00        	movl	$1, -8(%rbp)
100003fa2: c7 45 f4 02 00 00 00        	movl	$2, -12(%rbp)
100003fa9: 8b 45 f8                    	movl	-8(%rbp), %eax
100003fac: 03 45 f4                    	addl	-12(%rbp), %eax
100003faf: 89 45 f0                    	movl	%eax, -16(%rbp)
100003fb2: 8b 45 f0                    	movl	-16(%rbp), %eax
100003fb5: 5d                          	popq	%rbp
100003fb6: c3                          	retq
```

典型的计算机系统的硬件组织结构图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev019jeoj31hc0u0dhq.jpg" style="zoom: 35%;" />

1. 二进制代码装载进内存，将第一条指令的地址写入 PC 寄存器
2. 读取指令：根据 PC 指针，取出指令
3. 分析指令：指令解码器分析指令类型，获取操作数
4. 执行指令：根据指令，通过寄存器、ALU 等进行计算

### 栈如何管理函数调用

执行函数时，函数的参数、内部变量都会依次压入到栈中。举个例子：

```c++
int main() {
  int x = 5;
  int y = 5;
  x = 100;
  int z = x + y;
  return z;
}
```

main 函数执行过程中，栈的变化如下图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzz9xybj31hc0u0di6.jpg" style="zoom: 35%;" />

当一个函数调用另一个函数时：

```c++
int add(num1, num2) {
  int x = num1;
  int y = num2;
  int ret = x + y;
  return ret;
}
int main() {
  int x = 5;
  int y = 6;
  x = 100;
  int z = add(x + y);
  return z;
}
```

调用 add 函数前，栈的状态：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzxh8uwj31hc0u00u1.jpg" style="zoom: 35%;" />

在 add 函数中，我们得到了 add 函数的结果 ret，存放在栈顶：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev01s4o1j31rg0snjuk.jpg" style="zoom: 35%;" />

add 函数执行完毕后，我们需要将栈的状态恢复到 main 函数上次执行时的状态，这个过程叫**恢复现场**。

为了恢复现场，在 main 函数调用 add 函数时，需要将 main 函数的栈顶指针（f92）保存到 ebp 寄存器中，恢复现场时，只需将 ebp 中的值存放到 esp 即可。

恢复现场前：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzztinlj31rg0ptn04.jpg" style="zoom: 25%;" />

恢复现场后：

（注意 esp 的值由 f97 变成了 f92，图里没画出 ebp 寄存器，它的值是 f92）

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev02pzmvj31rg0ptq65.jpg" style="zoom: 25%;" />

这里还有一个问题，在执行 add 函数前，ebp 中是有值的，它的值是调用 main 函数前的栈顶地址（f91）。

为了恢复这个值，通常的方法是在 main 函数中调用 add 函数时，将当前 main 函数的**栈帧指针**保存在栈中：（总的来说，就是寄存器不够，只能挪来挪去。）

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzxvau0j31rg0tago4.jpg" style="zoom: 25%;" />

### 字节码

早期的 V8 是将 JavaScript 代码翻译成 AST 后，直接翻译成未优化的二进制代码执行的。现在的 V8 使用了字节码 + 解释器 + 编译器的方式。这中间的发展历史略过。

不使用字节码有两个问题：

* 编译时间过久，影响启动速度
* 缓存二进制代码会占用更多内存

使用字节码有三个好处：

* 编译生成字节码需要的时间短
* 占用内存不多，缓存字节码会大大降低内存占用
* 屏蔽底层细节，可移植性强

#### 生成字节码

在 V8 中，JavaScript 代码解析成 AST 和作用域信息后，Ignition 解释器会将其转化为字节码，然后同样由 Ignition 解释器执行。

考虑以下代码：

```javascript
function add(x, y) {
  var z = x + y
  return z
}
```

这段代码解析后的 AST 可以通过以下命令查看：

```shell
d8 --print-ast code.js
```

```
[generating bytecode for function: add]
-- - AST-- -
FUNC at 12
KIND0
LITERAL ID 1
SUSPEND COUNT 0
NAME "add"
PARAMS
  VAR(0x7fa7bf8048e8)(mode = VAR, assigned = false) "x"
  VAR(0x7fa7bf804990)(mode = VAR, assigned = false) "y"
DECLS
  VARIABLE(0x7fa7bf8048e8)(mode = VAR, assigned = false) "x"
  VARIABLE(0x7fa7bf804990)(mode = VAR, assigned = false) "y"
  VARIABLE(0x7fa7bf804a38)(mode = VAR, assigned = false) "z"
BLOCK NOCOMPLETIONS at - 1
  EXPRESSION STATEMENT at 31
    INITat31
      VAR PROXY local[0](0x7fa7bf804a38)(mode = VAR, assigned = false) "z" 19
      VAR PROXY parameter[0](0x7fa7bf8048e8)(mode = VAR, assigned = false 21
      VAR PROXY parameter[1](0x7fa7bf804990)(mode = VAR, assigned = false 22
      RETURN at 37
      VAR PROXY local[0](0x7fa7bf804a38)(mode = VAR, assigned = false) "z"
```

AST 用图表示如下：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev00detgj31hc0u0wge.jpg" style="zoom: 35%;" />

add 函数的作用域可以用 `--print-scopes` 打印：

```javascript
Global scope:
function add(x, y) { // (0x7f9ed7849468) (12, 47)
  // will be compiled
  // 1 stack slots
  // local vars:
  VAR y;  // (0x7f9ed7849790) parameter[1], never assigned
  VAR z;  // (0x7f9ed7849838) local[0], never assigned
  VAR x;  // (0x7f9ed78496e8) parameter[0], never assigned
}
```

作用域和实际数据的关系图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwev0331pfj31rg0qymz5.jpg" style="zoom: 25%;" />

有了 AST 和作用域，Ignition 解释器可以生成字节码，字节码用`--print-bytecode`查看：

```
[generated bytecode for function:  (0x38a0081d3141 <SharedFunctionInfo>)]
Bytecode length: 13
Parameter count 1
Register count 2
Frame size 16
OSR nesting level: 0
Bytecode Age: 0
    0x38a0081d31f6 @    0 : 13 00             LdaConstant [0]
    0x38a0081d31f8 @    2 : c3                Star0
    0x38a0081d31f9 @    3 : 19 fe f9          Mov <closure>, r1
    0x38a0081d31fc @    6 : 64 4f 01 fa 02    CallRuntime [DeclareGlobals], r0-r1
    0x38a0081d3201 @   11 : 0e                LdaUndefined
    0x38a0081d3202 @   12 : a8                Return
Constant pool (size = 1)
Handler Table (size = 0)
Source Position Table (size = 0)
```

字节码便是其中的：

```assembly
LdaConstant [0]
Star0
Mov <closure>, r1
CallRuntime
LdaUndefined
Return
```

#### 执行字节码

解释器就是一个虚拟机，虚拟机有两种，基于栈和基于寄存器。

基于寄存器的解释器架构如下图：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gweuzx8dncj31hc0u00u1.jpg" style="zoom: 25%;" />
