# 异步编程

## 同步、异步回调函数

回调函数有两种：同步回调和异步回调。

同步回调和异步回调的最大区别在于：**同步回调函数是在执行函数内部被执行的，异步回调函数是在执行函数外部被执行的。**

```javascript
function handle(name, index){
  console.log(index, name);
}
["water", "goods", "like"].forEach(handle)
```

handle 函数是在 forEach 函数内部执行的，这是同步回调。

```javascript
function foo() {}
setTimeout(foo, 3000)
```

setTimeout 函数执行后会立即返回，3秒后 foo 函数才会被执行，foo 函数是在 setTimeout 函数外被执行的，这是异步回调。

那么 foo 函数具体是在哪里被执行的呢，这里需要介绍事件循环队列。

## 事件循环队列

UI 线程之外有一个队列，待执行事件会被添加到队列中，UI 线程会不断从队列中取出、执行事件。

UI 线程每次从队列中取出、执行事件的过程称为一个任务。

整个流程大致如下所示:

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwcn8pk22aj31hc0u0gnx.jpg" style="zoom: 40%;" />

这里用 XMLHttpRequest 为例介绍异步回调过程：

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwcn8os9loj31hc0u0tai.jpg" style="zoom: 35%;" />

1. UI 线程从队列中取出一个任务，该任务是一个下载请求，主线程将任务交给网络线程执行
2. 网络线程接到请求之后，和服务器端建立连接，并发出下载请求;
3. 网络线程不断地收到服务器端传过来的数据
4. 网络线程每次接收到数据，将设置的回调函数和返回的数据信息，如字节数、数据位置等信息封装成一个事件，并将事件放到队列中

除了下载，JavaScript 中获取系统设备信息、文件读取等操作都是以类似的方式实现的。

## 宏任务、微任务

上文介绍了事件循环队列，队列中的任务称为**宏任务**。

**微任务可以看成一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。**

JavaScript 引入微任务是因为宏任务的时间粒度太粗，无法胜任一些对精度和实时性要求更高的场景，**微任务可以在实时性和效率之间做一个有效的权衡**。

下面主要介绍微任务。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwcn8q9j37j31rg0o0772.jpg" style="zoom: 25%;" />

微任务是基于事件循环队列、事件循环、UI 主线程还有堆栈的。基于微任务，又可以延伸出协程、Promise、Generator、await / async 等。

### 主线程、调用栈、事件循环队列

用一个例子来观察主线程、调用栈、事件循环队列三者间的关系。

```javascript
function foo() {
  setTimeout(foo, 0)
}
foo()
```

foo 函数执行前的状态：

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddeo24scj31kx0u0gnv.jpg" style="zoom: 33%;" />

执行 foo 函数时，会创建 foo 函数的执行上下文并入栈，然后 setTimeout 会将 foo 函数封装成一个宏任务并入队：

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwdderrgk5j31rg0tego8.jpg" style="zoom:33%;" />

foo 函数执行结束后，当前的宏任务也就结束了，调用栈也会被清空。

一个宏任务结束后，继续执行队列中的其他任务，直到某一刻轮到 setTimeout 函数创建的宏任务：

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddeoeomyj31rg0tl40p.jpg" style="zoom:33%;" />

最后，foo 函数再次被执行。这个过程会一直循环下去，但由于每次宏任务都使 “foo 函数执行上下文” 出栈，因此不会栈溢出。

### 微任务

**微任务会在当前宏任务快要结束时执行**。

```javascript
function foo() {
  console.log('foo')
  Promise.resolve().then(
  	() => console.log('micro-foo')
  )
  setTimeout(() => console.log('macro-foo'), 0)
  bar();
}

function bar() {
  console.log('bar')
  Promise.resolve().then(
  	() => console.log('micro-bar')
  )
  setTimeout(() => console.log('macro-bar'), 0)
}

foo()
console.log('global')
Promise.resolve().then(
  () => console.log('micro-global')
)
setTimeout(() => console.log('macro-global'), 0)
```

执行结果：

```javascript
foo
bar
global
micro-foo
micro-bar
micro-global
macro-foo
macro-bar
macro-global
```

初始状态下，调用栈中包含全局执行上下文，微任务队列为空：

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddera1zvj31mj0u00wl.jpg" style="zoom: 33%;" />

调用 foo 函数，会创建微任务 micro-foo 和 宏任务 macro-foo，微任务进入微任务队列，宏任务进入事件循环队列。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddepub29j31l90u0q76.jpg" style="zoom:33%;" />

foo 函数调用 bar 函数，bar 函数中创建了微任务 micro-bar 和 宏任务 macro-bar。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddeqepfdj31ks0u0n1m.jpg" style="zoom:33%;" />

接下来，bar 函数执行完毕退出，bar 函数的执行上下文出栈，紧接着 foo 函数也结束，foo 函数的上下文也出栈。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddeqz73qj31nf0u0gps.jpg" style="zoom:33%;" />

foo 函数执行完毕后，会执行全局环境的代码，这里会创建微任务 micro-global 和 宏任务 macro-global。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddeoyh4sj31ny0u00x7.jpg" style="zoom:33%;" />

然后重点来了，此时需要销毁全局执行上下文，在销毁之前，需要依次执行微任务队列中的任务，即 micro-foo、micro-bar、micro-global。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddes9rngj31o00u0dkp.jpg" style="zoom:33%;" />

微任务队列清空后，当前宏任务也要结束了，然后依次执行宏任务 macro-foo、macro-bar、macro-global。全部执行完毕后的状态：

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwddepgtisj31mj0u0ta9.jpg" style="zoom: 33%;" />

### 微任务中触发微任务

```javascript
function foo() {
  return Promise.resolve().then(foo)
}
foo()
```

这段代码中，foo 函数会创建微任务 foo，每次 foo 函数执行完之前会执行微任务，又会继续创建微任务。如此循环，当前宏任务便无法退出，意味着其他宏任务无法执行，比如鼠标、键盘事件，页面无法响应事件。

## 异步编程范式

异步编程方案的演变可以用下图表示：

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwdli9uec2j31hc0u0jsq.jpg" style="zoom:33%;" />

总的来说：

* 回调函数有回调地狱和函数控制权转移的问题
* promise 虽然符合线性思路，但是流程复杂时，promise 会充满 then 方法，语义不明显
* generator 函数可以暂停函数执行，等异步返回了结果再恢复执行
* async / await 则改进了 generator 的缺点，可以在不阻塞主线程的情况下，用同步代码实现异步功能

### 生成器 generator

其中值得一说的是，生成器函数是如何实现函数的暂停和恢复执行的。

答案就是协程。**协程是一种比线程更轻量级的存在**。

可以认为协程是跑在线程上的任务。一个线程可以存在多个协程，但是线程同时只能执行一个协程。

最重要的是，协程不是被操作系统内核管理，而完全是由程序控制(用户态执行)。这样的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

```javascript
function* getResult() {
	yield 'getUserID'
	yield 'getUserName'
	return 'name'
}
let result = getResult()

console.log(result.next().value)
console.log(result.next().value)
console.log(result.next().value)
```



<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwdlia80dbj31rg0svade.jpg" style="zoom:33%;" />

### async / await

async / await 背后就是 promise 和 generator。往底层说，就是微任务和协程。

根据 MDN 定义，async 是一个通过**异步执行并隐式返回 Promise** 作为结果的函数。

简单地理解，如果在 async 函数里面使用了 await， async 函数就会暂停执行，并等待合适的时机来恢复执行，所以说 async 是一个异步执行的函数。

通常，await 可以等待两种类型的表达式:

* 任何普通表达式
* promise 表达式

async 是一个可以暂停和恢复执行的函数，await 可以暂停函数执行，await 等待的是一个 promise 对象，这个 promise resolve 后恢复执行。
