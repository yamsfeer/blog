# 图解 Google V8

V8 是 JavaScript 虚拟机的一种，能够编译、解释、执行 JavaScript 代码。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gw5s35p8kkj30vq08kwfb.jpg" style="zoom: 60%;" />

JavaScript 借鉴了很多语言的特性，比如 C 语言的基本语法、Java 的类型系统和内存管理、Schema 的函数作为一等公民、Self 基于原型的继承机制。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gw5t6aynftj30vq0cdta3.jpg" style="zoom:50%;" />

V8 执行 JavaScript 代码的流程如下图：

![](http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gw5t6bvnv8j30vq0gs0uk.jpg)

本文会介绍 JavaScript 的一些语言特性，比如原型链、作用域链，然后介绍 V8 是如何实现这些特性的，除此之外，还会介绍两个重要功能：异步编程、内存管理 ( 垃圾回收 )。

## V8 执行 JS

### 准备工作

V8 启动前，需要准备一些基础环境，包括“堆空间”、”栈空间“、”全局执行上下文“、”全局作用域“、”消息循环系统“、”内置函数“等。

* 全局执行上下文：包含执行过程中的全局信息，比如一些内置函数、全局变量等
* 全局作用域：包含全局变量
* 堆、栈：V8 采用了经典的堆和栈的内存管理模式
* 事件循环系统：包含事件驱动器和事件循环队列，它们不断接受并处理事件

### 解释执行 & 编译执行

解释执行：将源代码通过编译转为中间代码，然后使用解释器解释执行中间代码。

<img src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gw5t6a7atij30vq06vaan.jpg" style="zoom:67%;" />

编译执行：将源代码转为中间代码，然后将中间代码转为二进制代码。

*( 二进制代码通常以二进制文件形式存储 )*

![](http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gw5t6bclzjj30vq096wf1.jpg)

V8 采用编译执行和解释执行两种方式，这种混合使用的方式称为 **JIT ( Just In Time )**。

* 解释执行：启动快，执行慢
* 编译执行：启动慢，执行快

### 具体执行过程

假设有如下代码保存在文件test.js中。

```javascript
var test = 'GeekTime'
```

这段代码会被转化为 AST。

通过 V8 提供的调试工具 D8 ( Debug for V8 )，可以查看 AST 的结构：

```shell
d8 --print-ast test.js
```

执行命令后，得到 AST 的结构：

```shell
--- AST ---
FUNC at 0
  KIND0
  LITERAL ID 0
  SUSPEND COUNT 0 6 . NAME ""
  INFERRED NAME ""
  DECLS
    VARIABLE (0x7ff0e3022298) (mode = VAR, assigned = true) "test"
  BLOCK NOCOMPLETIONS at -1
    EXPRESSION STATEMENT at 11
      INITat11
        VAR PROXY unallocated (0x7ff0e3022298) (mode = VAR, assigned = true)
        LITERAL "GeekTime"
```

<img class="img-mid" src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gw91ivds6kj30vq0awq3c.jpg" style="zoom: 55%;" />

前面提到，在生成 AST 的同时，还会生成作用域，通过 D8 来查看：

```shell
d8 --print-scopes test.js
```

test.js 的代码声明了一个全局变量，可以看到 test 变量被加入到了全局作用域中。

```shell
Global scope:
global { // (0x7fd974022048) (0, 24)
	// will be compiled
	// 1 stack slots
	// temporary vars:
	TEMPORARY .result;  // (0x7fd9740223c8) local[0]
	// local vars:
	VAR test;  // (0x7fd974022298)
}
```

生成 AST 和作用域后，就可以使用解释器生成字节码了。

```shell
d8 --print-bytecode test.js
```

```shell
[generated bytecode for function:  (0x02f7081d3125 <SharedFunctionInfo>)]
Bytecode length: 18
Parameter count 1
Register count 3
Frame size 24
OSR nesting level: 0
Bytecode Age: 0
     0x2f7081d31aa @    0 : 13 00             LdaConstant [0]
     0x2f7081d31ac @    2 : c2                Star1
     0x2f7081d31ad @    3 : 19 fe f8          Mov <closure>, r2
     0x2f7081d31b0 @    6 : 64 4f 01 f9 02    CallRuntime [DeclareGlobals], r1-r2
     0x2f7081d31b5 @   11 : 13 01             LdaConstant [1]
     0x2f7081d31b7 @   13 : 23 02 00          StaGlobal [2], [0]
     0x2f7081d31ba @   16 : 0e                LdaUndefined
     0x2f7081d31bb @   17 : a8                Return
Constant pool (size = 3)
Handler Table (size = 0)
Source Position Table (size = 0)
```

生成字节码后，解释器会执行这段字节码。

如果重复执行了某段代码，监控器会将其标记为热点代码，并提交编译器优化。

D8 可以查看被优化的代码和被反优化的代码。

```shell
d8 --print-opt-source test.js
d8 --print-deopt-stress test.js
```

很明显这段代码过于简单，没有触发 V8 的优化机制。

## JavaScript 的语言特性

### 函数

在 JavaScript 中，函数是“可被调用的对象”。

为了实现函数可调用特性，V8 会为函数对象添加两个**隐藏属性**：name 和 code。

<img class="img-mid" src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gw91iwb7u2j30vq0f3q48.jpg" style="zoom:67%;" />

* name 是函数名称

  如果函数没有设置函数名 ( 匿名函数 )，则默认值为 anonymous。

* code 是函数代码

  以**字符串**形式存储在内存中，当执行到函数调用语句时，V8 便从函数对象中取出 code，然后解释执行。

### 原型链

JavaScript 是基于原型的面向对象语言，面向对象有三大特性：封装、继承、多态。

在 JavaScript 中，封装可用 Proxy；继承使用原型链；JavaScript  作为动态类型语言，自带多态特性。

### 作用域链

作用域链就是将一个个作用域串起来，实现变量查找的路径。

JavaScript 中有三种作用域：

* 全局作用域：V8 启动时创建，且一直保存在内存中不会被销毁，直至 V8 退出
* 函数作用域：执行函数时创建，函数执行结束后销毁
* 块作用域：JavaScript 采用的是**词法作用域**

### 类型转换

当运行加法时，V8 会严格根据 ECMAScript 规范来执行操作。规范如下：

> * 把第一个表达式 (AdditiveExpression) 的值赋值给左引用 (lref)。
> *  使用 GetValue(lref) 获取左引用 (lref) 的计算结果，并赋值给左值。
> *  ...
> *  把 ToNumber(rprim) 的结果赋给右数字 (rnum)。
> *  返回左数字 (lnum) 和右数字 (rnum) 相加的数值。

通俗地理解，V8 会提供了一个 ToPrimitve 方法，作用是将 a 和 b 转换为原生数据类型，转换流程如下:

1. 先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，就使用该值进行强制类型转换;
2. 如果 valueOf 没有返回原始类型，就使用 toString 方法的返回值;
3. 如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发 TypeError 错误

<img class="img-mid" src="http://rt9iekfji.hn-bkt.clouddn.com/008i3skNgy1gwaejd2ptaj31hc0u0wgh.jpg" style="zoom: 33%;" />
