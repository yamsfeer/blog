# LL(1)分析算法

**LL(1)分析算法**的意思是：**从左(Left)向右读入程序，选择最左(L)推导，采用一个(1)前看符号**。

跟**递归下降分析算法**相同，LL(1)分析算法也有分析高效（线性时间）、错误定位和诊断信息准确等优点。

该算法可以应用于**语法分析器生成器**中，比如[ANTLR](https://zh.wikipedia.org/zh-cn/ANTLR)，类似的生成器还有`YACC`、`bison`等。

>ANTLR是基于LL算法实现的语法解析器生成器，用Java语言编写，使用自上而下的递归下降LL剖析器方法。

## 一个例子

回顾之前自顶向下分析的例子，给定文法$G$如下，推导句子`g d w`：

```
S -> N V N
N -> s
   | t
   | g
   | w
V -> e
   | d
```

自顶向下的分析算法如下：

```c
tokens[];
i = 0;
stack = [S];
while(stack not empty)
  if(stack[top] is a terminal t)
    t == tokens[i++]
    	? pop()
    	: backtrack(); // 终结符t与目标字符不等，回溯
  else if(stack[top] is a nonterminal T)
    pop();
    push(the next right hand side of T); // 选择T的右边压栈
```

`backtrack`函数是这个算法的回溯操作，这使得算法性能较低。而算法需要回溯，原因出在最后一行的压栈操作上。`选择T的右边压栈`是不能保证下一次匹配成功的。

比如当推导`gdw`中的`g`时，会逐次压入`N`的右部，按照`s，t，g，w `的顺序压入。其实可以直接压入`g`，如果`g`不匹配，则直接报错。

**如果每次都能把“正确的”那个压栈，就可以避免回溯。**

假设我们针对文法$G$有以下这张**LL(1) 分析表**：

```
S -> N V N
N -> s
   | t
   | g
   | w
V -> e
   | d
```

| N \ T |  s   |  t   |  g   |  w   |  e   |  d   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|   S   |  0   |  0   |  0   |  0   |      |      |
|   N   |  1   |  2   |  3   |  4   |      |      |
|   V   |      |      |      |      |  5   |  6   |

*行是非终结符，列是终结符（前看符号），表中数字对应的是文法中产生式规则标号（行号，从0开始）。*

每当推导遇到**非终结符N**时，可以根据**非终结符N**和当前**前看符号**查**LL(1)分析表**，得出**正确的符号**压栈。

有了分析表，对句子`g d w`的分析过程如下：

1. 栈顶元素为`S`
2. `S`出栈，前看符号是`g`。查分析表，第0条产生式（`S -> N V N`）的右部，也就是`N，V，N`依次入栈。当前栈底到栈顶元素为`N V N`
3. 栈顶`N`出栈，前看符号是`g`。查分析表，第3条产生式（`N -> g`）的右部入栈。当前栈底到栈顶元素为`N V g`
4. 栈顶元素`g`是非终结符且`g == 前看符号`。`g`出栈，前看符号变为`d`
5. 重复上述步骤

## 表驱动的LL分析器架构

上述例子的大体流程可以用以下示意图表示：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gt1qlr4018j30e605wt8t.jpg)

在这个过程中，我们需要通过查找**分析表**来得出压栈的符号，因此称为**表驱动**的LL分析。

那么，如何通过上下文无关文法$G$得出分析表就是接下来要分析的。

## FIRST集

还是这个`主谓宾`的例子：

```
S -> N V N
N -> s
   | t
   | g
   | w
V -> e
   | d
```

在这个文法中，句子都以$N$开头。而$N$能推导出$\{s, t, g, w\}$，所以所有句子必然以$\{s, t, g, w\}$集合中的其中一个字符开头。

将这个集合称为$FIRST(N)$，有$FIRST(N) = \{s, t, g, w\}$。

* 对产生式$N \to abc$，有$FIRST(N) = FIRST(N) \cup \{a\} $
* 对产生式$N \to Mbc$，有$FIRST(N) = FIRST(N) \cup FIRST(M) $

### FIRST集的近似不动点算法

求一个文法中所有非终结符的FIRST集的伪代码如下：

```c
foreach (nonterminal N) // 对文法中所有的非终结符做循环
  FIRST(N) = {}

while (some set is changing) // 循环至不再变化
  foreach (production p: N -> β1...βn) // 对所有产生式做循环
    if (β1 is terminal t) // 如果产生式以终结符t开头
      FIRST(N) U= {t}
    else if (β1 is nonterminal M) // 如果产生式以非终结符M开头
      FIRST(N) U= FIRST(M)
```

针对`主谓宾`的例子，计算过程用表表示如下：

| N\FIRST |  0（初始）  |    1次循环    |    2次循环    | 3次循环  |
| :-----: | :---------: | :-----------: | :-----------: | :------: |
|    S    | $\emptyset$ |  $\emptyset$  | $\{s,t,g,w\}$ | 不再变化 |
|    N    | $\emptyset$ | $\{s,t,g,w\}$ |   不再变化    |          |
|    V    | $\emptyset$ |   $\{e,d\}$   |   不再变化    |          |

由此可得表：

|  N   |     FIRST(N)     |
| :--: | :--------------: |
|  S   | $\{s, t, g, w\}$ |
|  N   | $\{s, t, g, w\}$ |
|  V   |    $\{e, d\}$    |

### 把 FIRST 集推广到任意串上

上面计算的是对**非终结符**的$FIRST$集的计算方法。

把FIRST集推广到任意产生式，有：

* $FIRST\_S(\beta_1\dots\beta_n) = FIRST(N), \quad \beta_1 = N$​​

* $FIRST\_S(\beta_1\dots\beta_n) = {t}, \quad \beta_1 = t$​​​​

有了上面非终结符的$FIRST$集表，不难得出各产生式的$FIRST\_S$集：

```
S -> N V N  // { s, t, g, w }
N -> s      // { s }
   | t      // { t }
   | g      // { g }
   | w      // { w }
V -> e      // { e }
   | d      // { d }
```

## 构造 LL(1) 分析表

上面我们已经得到了整个文法$G$的$FIRST\_S$集：

```
0: S -> N V N  // { s, t, g, w }
1: N -> s      // { s }
2:    | t      // { t }
3:    | g      // { g }
4:    | w      // { w }
5: V -> e      // { e }
6:    | d      // { d }
```

以产生式`S -> NVN`为例，如果当前前看符号是`s`、`t`、`g`、`w`的话，则将`S -> NVN`的行号`0`入栈。

由此我们可以整理得到LL(1)分析表如下：

| N \ T |  s   |  t   |  g   |  w   |  e   |  d   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: |
|   S   |  0   |  0   |  0   |  0   |      |      |
|   N   |  1   |  2   |  3   |  4   |      |      |
|   V   |      |      |      |      |  5   |  6   |

### LL(1) 分析表中的冲突

对与一个文法$G$构建出的`LL(1)`分析表，如果

* 每个表项**最多只有一个元素**，$G$称为`LL(1)文法`。
* 每个表项的**元素个数大于1**，称为`LL(1)分析表`的**冲突**。

假设有如下文法$G$：

```
0: S -> N V N  // { s, t, g, w }
1: N -> s      // { s }
2:    | t      // { t }
3:    | g      // { g }
4:    | w      // { w }
5:    | w V    // { w } 注意这行
6: V -> e      // { e }
7:    | d      // { d }
```

相对应的分析表如下：

| N \ T |  s   |  t   |  g   |     w      |  e   |  d   |
| :---: | :--: | :--: | :--: | :--------: | :--: | :--: |
|   S   |  0   |  0   |  0   |     0      |      |      |
|   N   |  1   |  2   |  3   | ***4, 5*** |      |      |
|   V   |      |      |      |            |  6   |  7   |

当非终结符为`N`且前看符号为`w`时，有`4`和`5`两种选择。

**这样的冲突会导致分析过程的不确定性，导致回溯的发生**。

对$N$的两条产生式 $N \to \beta$​ 和 $N \to \gamma$​​​，如果
$$
FIRST\_S(N \to \beta) \cap FIRST\_S(N \to \gamma) = \emptyset
$$
则没有冲突。

然而：
$$
FIRST\_S(N \to w) \cap FIRST\_S(N \to w V) = \{w\} \ne \emptyset
$$
文法$G$不是一个`LL(1)文法`。

## 一般情况下的LL(1)分析表

```
Z -> d
   | X Y Z
Y -> c
   | ε
X -> Y
   | a
```



### NULLABLE 集合

### NULLABLE 集合算法

### FIRST 集合的完整计算公式

### FIRST 集的完整不动点算法

### FOLLOW 集的不动点算法

### 计算 FIRST_S 集合

### LL(1) 分析器

### LL(1) 分析冲突处理

#### 消除左递归

#### 提取左公因子
