# vue3原理

Vue2 响应式原理 getter setter 的缺点：

- 默认会递归、消耗较大
- 数组响应化需要额外实现
- 新增/删除属性属性无法监听
- Map、Set、Class 等无法响应式，修改语法有限制

proxy 的优点：

- `Proxy` 可以直接监听对象而非属性；
- `Proxy` 可以直接监听数组的变化；
- `Proxy` 有多达 13 种拦截方法,不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等等是 `Object.defineProperty` 不具备的；
- `Proxy` 返回的是一个新对象,我们可以只操作新的对象达到目的,而 `Object.defineProperty` 只能遍历对象属性直接修改；
- `Proxy` 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。

## vue3 的改进

### 源码维护

* typescript

  更好的类型检查、有利于类型定义

* monorepo

  package 独立，可单独使用和测试

### 性能

* 更小的代码体积

  * tree-shaking

* proxy 比 getter setter 的优点

  https://tehub.com/a/8K18hoz9Cj

  * 深层嵌套
  * 无法劫持新的属性

*  编译优化

### 代码逻辑组织优化

* mixins



composition API

* 优势
* 缺点





[shape & patchFlag](https://segmentfault.com/a/1190000042563157)

https://juejin.cn/post/7049358090445160462#heading-3

https://wumanho.cn/posts/vueshapeflags/#%E6%B7%BB%E5%8A%A0-shapeflag



### baseRender

```javascript
// { patchProps() {}, nodeOps: {}}
function baseCreateRenderer(options) {
  patch()

  /* Text */
  processText()

  /* Comment */
  processCommentNode()
  mountStaticNode()
  patchStaticNode(), moveStaticNode(), removeStaticNode()
 	
  /* Element */
  processElement()
  mountElement()
  setScopeId()
  mountChildren()

  /* diff */
  patchElement()
  patchChildren
  patchKeyedChildren
  patchUnkeyedChildren
 
  patchBlockChildren()
  patchProps()
  
  /* Fragment */
  processFragment()
  
  /* Component */
  processComponent()
  mountComponent()
  updateComponent()
  setupRenderEffect()
  updateComponentPreRender

  move
  unmount
  remove
  removeFragment
  unmountComponent
  unmountChildren
  getNextHostNode
  render
  
  return {
    render
    createApp: createAppAPI(render)
  }
}
```



mountComponent:

* 创建组件实例 createComponentInstance
* 设置组件实例 setupComponent
* 设置并运行带副作用的渲染函数 setupRenderEffect



```
patch
  - processText
  - processElement
    - mountElement
    - patchElement
    - mountChildren
  - processComponent
    - mountComponent
    - updateComponent
```

