# 响应系统( Reactivity )

## 基本实现

```javascript
function reactive(target) {
  const proxy = new Proxy(target, {
    get(target, key, receiver) {
      track(target, key)
      return Reflect.get(target, key, receiver)
    },
    set(target, key, receiver) {
      trigger(target, key)
      return Reflect.set(target, key, receiver)
    }
  })
  return proxy
}
```



```javascript
const targetMap = new WeakMap()

function track(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap.set(target, (depsMap = new WeakMap()))
  }
  const deps = depsMap.get(key)
  if (!deps) {
    depsMap.set(key, (deps = new Set()))
  }
  
  deps.add(activeEffect)
}
```



```javascript
function trigger(target, key) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return
  
  const deps = depsMap.get(key)
  if (!deps) return
  
  deps.forEach(effectFn => effectFn())
}
```



```javascript
let activeEffect = null

function effect(fn) {
  function effectFn() {
    activeEffect = effectFn
    fn()
  }
  
  return effectFn
}
```





### cleanup

```javascript
function track(target, key) {
  deps.add(activeEffect)
  activeEffect.deps.push(deps) // 双向持有对方引用
}
```



```javascript
function effect(fn) {
  function effectFn() {
    cleanup(effectFn)
    activeEffect = effectFn
    fn()
  }
  
  effectFn.deps = []
}
```



```javascript
function cleanup(effectFn) {
  effectFn.deps.forEach(deps => {
    deps.delete(effectFn) // 清空
  })
  effectFn.deps.length = 0 // 清空
}
```



```javascript
function trigger(target, key) {
  const deps = depsMap.get(key)
  // deps.forEach(effectFn => effectFn())
  
  const effectsToRun = new Set(deps)
  effectsToRun.forEach(effectFn => effectFn())
}
```





### 嵌套 effect



```javascript
let activeEffect
let effectStack = []

function effect(fn) {
  function effectFn() {
    cleanup(activeEffect)
    
    // 副作用函数入栈
    activeEffect = effectFn
    effectStack.push(effectFn)
    
    fn() // 执行副作用函数

    // 恢复副作用栈
    effectStack.pop()
    activeEffect = effectStack[effectStack.length - 1]
  }
}
```





### 无限递归循环



```javascript
function trigger(target, key) {
  const effects = depsMap.get(key)
  
  const effectsToRun = new Set()
  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行的副作用函数等于当前正在执行的副作用函数，则不触发执行
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  effectsToRun.forEach(effectFn => effectFn())
}
```





### 调度执行

## computed

## watch
