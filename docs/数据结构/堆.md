# 堆 ( heap )

堆可分为最大堆，最小堆。

* 最大堆：所有子树的根节点不小于左右孩子
* 最小堆：所有子树的根节点不大于左右孩子

最大最小堆都是一颗完全二叉树，因此可用数组来存储堆

```
      0
    /   \
   1     2
  / \   / \
 3   4  5
```

在数组中的存储刚好是 012345，且有:

```javascript
parent(n) = floor((n - 1) / 2)
lchild(n) = n * 2 + 1
rchild(n) = n * 2 + 2
```

## siftUp

以最大堆为例，当将一个新元素e插入数组末尾时，可能会破坏堆序性，

但是这个新元素只会影响它所在的子树，

如果e > parent(e)，则与父节点交换

上一步交换后可能仍不满足堆序性，因此可能需要逐层向上交换直到根节点

## siftDown

以最大堆为例，在删除最大元delMax操作中，

为保持堆结构，可将数组最后一个元素e和堆顶元素交换，

然后将堆顶元素e与它的左右孩子比较，然后与左右孩子中的较大者交换，循环直至e为叶子节点

## heapify

## replace

## 实现

```javascript
class Heap {
  constructor() {
    // 从 0 开始
    // lchild = i * 2 + 1
    // rchild = i * 2 + 2
    // parent = ( i - 1 ) / 2
    this.data = []
  }

  size() {
    return this.data.length
  }

  peek() {
    if (!this.size()) {
      return null
    }
    return this.data[0]
  }

  add(element) {
    this.data.push(element)
    this.siftUp(this.data.length - 1) // 先推入尾结点，然后 siftUp
  }

  pop() {
    if (!this.size()) {
      return null
    }
    const head = this.data[0]
    this.data[0] = this.data.pop() // 将最后一个节点替换根节点，然后 siftDown
    this.siftDown(0)
    return head
  }

  swap(i, j) {
    const temp = this.data[i]
    this.data[i] = this.data[j]
    this.data[j] = temp
  }

  siftUp(i) {
    while(i > 0) {
      const parent = Math.floor((i - 1) / 2)
      if (this.data[i] <= this.data[parent]) {
        break
      }
      this.swap(i, parent)
      i = parent
    }
  }

  siftDown(i) {
    const data = this.data
    while(i < this.size()) {
      const lchild = i * 2 + 1
      const rchild = i * 2 + 2

      if (lchild >= this.size()) { // 左孩子越界，右孩子肯定越界
        break
      }
      if (rchild >= this.size()) { // 只有左孩子
        if (data[i] < data[lchild]) {
          this.swap(i, lchild)
          i = lchild
        } else {
          break
        }
      } else { // 有左右孩子
        const maxChild = data[lchild] > data[rchild] ? lchild : rchild // 找出较大孩子的 index
        if (data[i] < data[maxChild]) { // 如果当前节点小于两个孩子节点
          this.swap(i, maxChild)
          i = maxChild
        } else {
          break
        }
      }
    }
  }
}
```

