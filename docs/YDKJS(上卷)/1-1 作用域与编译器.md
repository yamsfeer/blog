# 作用域与编译器

## 作用域

几乎所有编程语言的基本功能之一，就是能够存储变量中的值，并且能够对其进行访问和修改。这种对变量的存储和访问的能力将**状态**带给了程序。

变量存储在哪里、如何找到它们、如何修改它的值······这些问题使得我们需要设计一套规则来存储变量，并在这之后访问变量，**这套规则称为作用域**。

### 编译原理

尽管```JavaScript ```通常被归类为“动态”或“解释执行”的语言，事实上她是一门编译语言。但与传统编译语言不同，她不是提前编译的，编译结果也不能在分布式系统中传播。

> 传统编译语言流程：
>
> * 分词/词法分析(Tokenizing/Lexing)
>
>   这个过程会将由字符组成的字符串分解为（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，考虑程序```let a = 2;```,这段程序会被分解为```let```、```a```、```=```、```2```、```;```。
>
> * 语法分析(Parsing)
>
>   这个过程会将词法单元流（token流数组）转换为一个由元素逐级嵌套组成的代表了程序语法结构的树，称之为**抽象语法树（Abstract Syntax Tree, AST）**。```let a = 2;```这段程序的AST中可能存在一个***VariableDeclaration***的顶级节点，然后会有一个***Identifier***的子节点，它的值是```a```，以及一个***AssignmentExpression***的子节点，***AssignmentExpression***节点有一个***NumericLiteral***的子节点，它的值是```2```。
>
>   ```mermaid
>   graph LR
>   VariableDeclaration --> Identifier[Identifier: a]
>   VariableDeclaration --> AssignmentExpression --> NumericLiteral[NumericLiteral: 2]
>   ```
>
>
>
> * 代码生成
>
>   将AST转换为可执行代码的过程称为代码生成。这个过程与语言、目标平台息息相关。简单来说，代码生成过程就是将AST转换为一组机器指令，可以创建一个叫做```a```的变量（包括分配内存等底层操作），并将值 `2` 存储在 `a` 中。

与其他传统编译器相比，JavaScript引擎可能要更加复杂，比如，在**语法分析**和**代码生成**阶段有特定的步骤对运行性能进行优化，包括**对冗余元素进行优化**等。

然而，JavaScript引擎不会像其他编译器一样有太多的时间进行优化，因为JavaScript的编译过程通常发生在代码执行的前几微秒内甚至更短。在这期间，JavaScript 引擎用尽了各种办法(比如 ***JIT***，可以延迟编译甚至实施重编译)来保证性能最佳。

总的来说，**任何JavaScript代码在执行前都需要编译**（通常就在执行前），JavaScript编译器会对程序进行编译，并准备执行它，通常马上就会执行。

## 理解作用域

> 参与JavaScript代码的编译和执行的几个对象：
>
> * 引擎
>
>   从头到尾负责整个JavaScript程序的编译和执行过程
>
> * 编译器
>
>   负责语法分析和代码生成
>
> * 作用域
>
>   负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

以```var a = 2;```这段代码为例，编译器会对其进行词法分析，得到token流，然后抽象成AST，在进行代码生成时，会进行如下操作：

1. 遇到```var a```，编译器会询问作用域是否已有一个相同名称的变量存在于相同作用域的集合中，

   如果有，则忽略该声明并继续编译；

   如果没有，它会要求作用域在当前作用域的集合中声明一个新的变量，命名为 `a`。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 ```a = 2``` 这个赋值操作。

   引擎运行时会首先询问作用域，在当前的作用域集合中是否存在名为 `a` 的变量，如果有，则使用这个变量，否则继续查找。

   如果最终找到变量 `a`，就会将`2` 赋值给它，否则引擎抛出一个异常。

**总结：变量的赋值操作会进行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。**

```flow
st=>start: 开始

tokenizing=>operation: 词法分析
parsing=>operation: 语法分析
genCode=>operation: 代码生成

e=>end: 结束

st->tokenizing->parsing->genCode



```



### LHS和RHS

为便于记忆，可以分别认为**LHS**和**RHS**是一个赋值操作的左侧和右侧进行的查询，换句话说，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

针对```var a = b;```这段代码，会进行**RHS**查询得到 `b` 的值，进行**LHS**查询是否存在变量 `a`，从而进行赋值。

准确的说，RHS 查询与简单地查找某个变量的值相同，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。

从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。

针对代码:

```javascript
1: function foo(a) {
2:  console.log( a ); // 2
3: }
4: foo( 2 );
```

* 第4行中需要对foo进行**RHS**查询，得到foo函数；

* 第1行中a作为型参，当调用foo函数时，会隐式地有 `a = 2`的操作，因此，这里要对a进行**LHS**查询。

* 第2行中，需要对a进行**RHS**查询从而将a的值传给```console.log```。

  当然，要得到 `log` 函数，会对 console 对象进行 **RHS** 查询，并且检查得到的值中是否有一个叫作 log 的方法。

### 作用域嵌套

我们说过，**作用域是根据名称查找变量的一套规则**。实际情况中，通常需要同时顾及几个作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。

![image-20210104154329370](https://tva1.sinaimg.cn/large/0081Kckwgy1gmbpi4c04aj30bm06yq31.jpg)

#### 作用域相关的异常

* 如果**RHS**在所有嵌套的作用域中找不到所需变量，那么会抛出一个 ***ReferenceError*** 异常，这是一个很重要的异常类型。

* 如果**LHS**最终在全局作用域中找不到所需变量，那么
  * 在**非严格模式**下，**全局作用域**中会创建一个同名变量并返回给引擎。
  * **严格模式**下，不会创建全局变量，而是抛出 ***ReferenceError*** 异常。
* 如果**RHS**查询到一个变量，但是尝试对其进行错误操作，比如对一个非函数类型进行函数调用，则抛出 ***TypeError*** 异常。
* ***ReferenceError*** 同作用域判别失败相关，而 ***TypeError*** 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。

## 总结

作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。

如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。

赋值操作符会导致 LHS 查询。`=` 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

* JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像 `var a = 2` 这样的声明会被分解成两个独立的步骤:

  1. 首先，`var a` 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。

  2. 接下来，`a = 2` 会查询(LHS 查询)变量 `a` 并对其进行赋值。

* LHS 和 RHS 查询都会在当前执行作用域中开始，逐级往上，最后抵达全局作用域，无论找到或没找到都将停止。

* 不成功的 RHS 引用会导致抛出 ***ReferenceError*** 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量(**非严格模式下**)，该变量使用 LHS 引用的目标作为标识符，或者抛出 ***ReferenceError*** 异常(**严格模式**下)。
