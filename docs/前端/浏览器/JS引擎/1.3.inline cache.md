# Inline Cache

## 函数惰性解析

解析过程中，如果遇到函数声明，会跳过函数内部的代码，暂不为其生成 AST 和字节码。

惰性解析可以加速启动速度，如果将所有代码一次性编译完成，会大大增加等待时间和内存占用。

然而，惰性解析在闭包场景中会有问题，为此，V8 引入了预解析器。

当解析时遇到一个函数，预解析器会对该函数做一次快速的预解析，其作用有两个：

* 判断是否存在语法上的错误
* 检查函数内部是否引用了外部变量，如果引用了，预解析器会将这些变量复制到堆中，当执行到该函数的时候，直接使用堆中的引用。

## 内联缓存 ( Inline Cache )

考虑以下代码：

```javascript
const obj = { x: 1, y: 2 }
const load = obj => obj.x

while(i++ < 10000) {
  load(obj)
}
```

获取 x 属性的过程：查找对象的隐藏类，通过隐藏类获取 x 的偏移量，根据偏移量获取属性值。

这个过程会反复执行，为了优化这个过程，V8 采取了 **内联缓存 ( Inline Cache )** 的策略。

### 什么是内联缓存

内联缓存会为每个**函数**维护一个**反馈向量 ( FeedBack Vector )**，反馈向量记录了函数执行过程中的一些**关键的中间数据**：

<img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gwcfkuz6cpj31rg0oqtbn.jpg" style="zoom:33%;" />

反馈向量是一个表结构，表的每一项称为一个**插槽 ( Slot )**，函数执行的中间数据存储在插槽中。

考虑以下代码：

```javascript
function load(o) {
  o.y = 4;
  return o.x;
}
```

这个函数有两个**调用点 ( CallSite )**，分别为 `o.y` 和 `o.x`，它们访问了对象和属性，V8 会在 load 函数的反馈向量中为每个调用点分配一个 slot。

每个插槽包括了索引 ( index )、类型 ( type )、状态 ( state )、隐藏类 ( map )、属性偏移量 ( offset )。

load 函数的反馈向量如下图：

<img class="img-mid" src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gwcfkvocqgj31rg0ougoc.jpg" style="zoom: 25%;" />

*(隐藏类 ( map ) 地址一样是因为访问的是同一个对象)*

### 反馈向量的写入过程

有如下代码：

```javascript
function load(o) {
  return o.x
}
```

load 函数转换为字节码：

```assembly
StackCheck # 检查栈是否溢出
LdaNamedProperty a0, [0], [0] # 取出参数 a0 的第一个属性值，放入累加器
Return # 返回累加器的值
```

这里我们重点关注 LdaNamedProperty 这句字节码，它有三个参数。

* 参数1：a0 就是 load 函数的第一个参数
* 参数2：[0] 表示取出对象 a0 的第一个属性值
* 参数3：和反馈向量有关，它表示将 LdaNamedProperty 操作的中间数据写入到反馈向量中，方括号中间的 0 表示写入反馈向量的第一个插槽。

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gwcfkx89doj31rg0fx40a.jpg" style="zoom: 40%;" />

* map 缓存了 o 的隐藏类的地址
* offset 缓存了属性 x 的偏移量;
* type 缓存了操作类型 LOAD。在反馈向量中，访问对象属性值的操作为 LOAD 类型。

type 中，除了 **LOAD** 操作，还有**存储 ( STORE )** 和**函数调用 ( CALL )**。

### STORE 和 CALL

再来看一段代码：

```javascript
function foo() {}
function load(o) {
  o.y = 4
  foo()
  return o.x
}
```

它的字节码如下：

```assembly
StackCheck
LdaSmi [4]
StaNamedProperty a0, [0], [0]
LdaGlobal [1], [2]
Star r0
CallUndefinedReceiver0 r0, [4]
LdaNamedProperty a0, [2], [6]
Return
```

这段字节码的执行过程如下图：

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gwcfkw5q3pj31jd0u0n0r.jpg" style="zoom:33%;" />

其中，`o.y = 4` 对应的字节码是：

```assembly
LdaSmi [4] # 将常数 4 加载到累加器
StaNamedProperty a0, [0], [0] # 将累加器中的值赋给 o.y
```

这是一个**存储 (STORE) 类型**操作，V8 会将操作的中间结果存放到反馈向量中的第一个插槽中。

调用 foo 函数的字节码:

```assembly
LdaGlobal [1], [2] # 加载 foo 函数对象的地址到累加器
Star r0
CallUndefinedReceiver0 r0, [4] # 调用函数
```

LdaGlobal：加载 foo 函数的地址到累加器中，然后将中间结果存入反馈向量第 3 个插槽，这是一个**存储 (STORE) 类型**操作。

CallUndefinedReceive：调用函数，将执行的中间结果存入反馈向量第 5 个插槽中，这是一个**调用 (CALL) 类型**操作。

最后就是返回 o.x，这是一个**加载 (LOAD) 类型**操作。

最终生成的反馈向量如下图所示:

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gwcfkws3hoj31rg0k176v.jpg" style="zoom: 25%;" />

有了这张表，下次执行 load 函数时就可以通过偏移量提高运行效率。

### 多态与超态

通过缓存执行过程中的基础信息，就能提升下次执行函数的效率。但是前提是多次执行时，对象的形状是固定的。如果形状不固定会怎么样呢？

来看一段代码：

```javascript
function load(o) {
  return o.x
}
let o1 = { x: 1 }
let o2 = { x: 1, y: 2 }
for(let i = 0; i < 10000; i++) {
  load(o1)
  load(o2)
}
```

可以看到对象 o1 和 o2 是不一样的，这意味着隐藏类也是不同的。

第一次执行时 load 时，o1 的隐藏类和偏移量会被记录。

再次调用 load 函数时，V8 会取出反馈向量中记录的隐藏类，并和 o2 的隐藏类比较，发现不是一个隐藏类。然后将新的隐藏类也记录在反馈向量中。

这时，第一个 slot 里就包含了两个隐藏类和偏移量：

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/008i3skNgy1gwcfkxk4ndj31rg0magnr.jpg" style="zoom: 25%;" />

* 一个插槽中只包含 1 个隐藏类，称为**单态 (monomorphic)**
* 一个插槽中包含了 2~4 个隐藏类，称为**多态 (polymorphic)**
* 一个插槽中超过 4 个隐藏类，称为**超态 (magamorphic)**

很明显**单态的性能优于多态和超态，**所以我们需要稍微避免多态和超态的情况。

要避免多态和超态，就尽量默认所有的对象属性是不变的。比如传入 load 函数的对象的形状要尽量保持一致。