# 资源加载

## 预加载：preload 和 prefetch

preload 和 prefetch 都可以预加载资源，使用起来大概如下：

```html
<link rel="preload" href="style.css" >
<link rel="prefetch" href="script.js" >
```

preload 和 prefetch 都是获取页面的关键资源，比如脚本、字体和图像。不同之处在于：preload 是尽快获取，当前页面很快要用；prefetch 是尽快获取，下个页面准备要用。

如果页面 A 为页面 B 的关键资源发起 prefetch 请求，关键资源和当前页面的请求可以并行完成；如果发起的是 preload 请求，它将在页面 A 卸载时取消，页面 B 也许会错过这次预加载。

值得注意的是，在 Chrome 中，如果用户离开一个页面，其他页面正在进行中的 prefetch 不会被终止。无论资源的可缓存性如何，prefetch 在网络堆栈缓存至少 5 分钟。

除了以上区别，preload 和 prefetch 在使用上是类似的，下面以 preload 为例介绍。

### 缓存行为

Chrome 有四个缓存：memory cache、Service Worker cache、HTTP cache ( disk cache )和 Push cache。

preload 和 prefetch 的资源都存储在 HTTP cache 中。

当一个资源被 preload 或 prefetch 时，它从网络请求栈上升到 HTTP cache 并进入渲染器的 memory cache。

* 如果该资源可以被缓存 ( 有效的 cache-control 和有效的 max-age )，它会被存储在 HTTP cache 中。

* 如果不可缓存，它不会进入 HTTP cache，而是进入 memory cache。

### 优先级

Chrome 分两个阶段加载资源：严格模式 ( tight mode ) 和条件严格模式。

在严格模式下，限制加载低优先级的资源 ( 正在进行的请求少于 2 个才会加载 )。head 标签中的 script 基本执行完后，进入条件严格模式。

* 每个资源类型都有一个默认的优先级，fetchpriority 可以影响这个优先级。
* 同一优先级的资源按其被发现的顺序排序获取。

chrome 的资源优先级如下表：

◉ : fetchpriority=”auto”

⬆ : fetchpriority=”high”

⬇ : fetchpriority=”low”

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/image-20230518124317778.png" alt="image-20230518124317778" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/image-20230518125659437.png" alt="image-20230518125659437" style="zoom:50%;" />

\* 使用 as 进行 preload 或使用 type 进行 prefetch 时，使用他们所请求的类型的优先级。例如，`<link rel="preload" as="style">` 将使用最高优先级，如果没有 as，它们的行为就像 XHR。

** early 表示在非预载图像之前 ( late 为之后 )。

*** media type 不匹配的 CSS 不会被 preload，所以它会较晚获取且有一个 late 优先级。

上图参考 [Resource Fetch Prioritization and Scheduling in Chromium](https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc/edit#)。

#### 优先级变化

* image 的默认优先级是 low，如果在布局时，发现图像在视口内，优先级会提升到 high。

* script 的默认优先级是 medium，HTML 解析到 script 时，优先级会提升到 high。

chrome 的 Dev tools 显示的是资源在完成加载时的最终优先级，一个图像从 low 提升到 high，它将显示为 high。优先级可以在 chrome 的 timeline / performance / network 面板中查看。

#### 网络堆栈优先级名称

Chrome 网络栈使用的 5 个优先级与上文介绍的优先级相同，只是名称略有不同。网络优先级的名称通常是全大写的。  完整的映射是：

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/image-20230518125557361.png" alt="image-20230518125557361" style="zoom:50%;" />

### preload 被用于什么

根据 [HTTPArchive](https://httparchive.org/)，大多数网站使用 preload 来做以下工作：

* 预加载 [Web 字体](https://www.zachleat.com/web/preload/)
* 通过 [loadCSS](https://github.com/filamentgroup/loadCSS) 异步加载 CSS
* PWA 程序使用 [PRPL](https://web.dev/apply-instant-loading-with-prpl/) 等模式，预加载当前页面所需的脚本

总的来说，你可以预加载脚本、图像，样式，字体，媒体等等。

```html
<link rel="preload" as="script" href="critical.js">
<link rel="preload" as="stylesheet" href="critical.css">
<link rel="preload" as="image" href="critical.webp">
<link rel="preload" as="font" href="ComicSans.woff2" type="font/woff2" crossorigin>
```

### 关于 preload 的建议

某些情况下，preload 和 prefetch 会导致重复下载资源。以下是防止重复获取的建议。

* 不要把 prefetch 作为 preload 的后备手段。

  前面提过，preload 是当前页面用，prefetch 是下个页面用，它们的目的不完全一样。

* 不要用 fetch API 进行 preload

  在 Chrome 中，用 fetch 进行 preload 会触发重复下载。

* 在 preload 时提供 as 属性

  没有有效的 as 属性会重复下载。

* preload 字体时，提供 crossorigin 属性

  preload 字体是匿名模式 CORS 请求的，不设置 crossorigin 将重复下载。即使字体与页面在同源，也建议写上 crossorigin。

* 暂不使用 integrity 属性

  link 元素的 integrity 属性表示资源文件的哈希值。它还不完善，可能导致重复请求且无法缓存。

### http preload

除了用 link 标签，http 的 link header 也可以指定预加载资源。

```http
Link: <https://example.com>; rel="preload";
```

这两种方式，preload 都会引导浏览器将资源加载到 memory cache 中，这表明页面想尽快使用它，而不想等待 preload scanner 或 HTML 解析器发现。

值得注意的是，许多服务器在遇到 http header 形式的预加载时启动 http2 的 Server Push，Server Push 与 preload 是不同的，后面会介绍。

所以，你应该使用 link 标签而不是 http header 的方式，从而避免不必要的推送。

### onload 事件

link 元素 preload 加载的文档支持 onload 事件。

```html
<link rel="preload" href="document URL" onload="console.log('加载完成')">
```

我们可以在回调中让预加载的样式表应用到文档。

```html
<link rel="preload" href="style.css" onload="this.rel=stylesheet">
```

### 相关文章

- [Preload, Prefetch And Priorities in Chrome](https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)
- [Preload — what is it good for?](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/)
- [A  study](https://twitter.com/ChromiumDev/status/837715866078752768) by the Chrome Data Saver team
- [Planning for performance](https://www.youtube.com/watch?v=RWLzUnESylc)
- [Webpack plugin](https://github.com/googlechrome/preload-webpack-plugin) for auto-wiring up `<link rel="preload">`
- [What is preload, prefetch and preconnect?](https://www.keycdn.com/blog/resource-hints/)
- [Web Fonts preloaded](https://www.zachleat.com/web/preload/)

## fetchpriority

浏览器下载各种类型资源有一个默认的优先级，[priority-hints](https://github.com/WICG/priority-hints/blob/main/EXPLAINER.md) 可以影响这个优先级。具体来说，是使用 `fetchpriority` 属性。

`fetchpriority` 属性可以在 `link`、`img`、`script` 标签中使用，它有三种可选值：

* high：相对默认优先级高
* low：相对默认优先级更低
* auto：默认值，相当于没有设置

```html
<img src="photo.png" fetchprioroty="high" />
```

注意，fetchpriority 只是一种提示而非要求，浏览器可以根据实际情况处理资源的优先级。

### 图片

通常来说，浏览器会按照文档中出现的顺序加载图像，当它发现图片在视口中，则会提高优先级。我们可以用 fetchpriority 给浏览器一个提示，以便更快获取重要的图像。

```html
<img src="logo.png">
<img src="product.jpg" fetchpriority="high">
<img src="carousel.jpg" fetchpriority="low">
```

### 异步脚本

浏览器对 blocking script、async script 和 preload script 有不同的优先级。

如果浏览器默认 preload script 为高优先级，async script 为低优先级，那么 preload 一个 async 脚本的依赖会有问题。

假如我们有两个脚本 A 和 B，A 导入 B，预加载 B 就可以在加载 A 的同时开始获取。

```html
<script src="A.js" async></script>
<link rel="preload" href="B.js" as="script">
```

但这可能会导致 B 先于 A 被加载，因为 preload 优先级高于 async。

通过 priority hints 为两个脚本分配相同的优先级，它们就可以按顺序加载。

```html
<script src="A.js" async fetchpriority="high"></script>
<link rel="preload" href="B.js" as="script" fetchpriority="high">
```

### fetch API

fetch API 也可以提供优先级提示。

```javascript
fetch('/api/prefetch.json', { priority: 'low' })
  .then(/*...*/)
```

## http2 push 和 preload

[Exploring Differences Between HTTP Preload vs HTTP/2 Push](https://www.keycdn.com/blog/http-preload-vs-http2-push)

http2 服务器推送 ( 以下统称 push ) 和 预加载 ( 以下统称 preload ) 有相似之处，但它们是两个不同的功能。

### 什么是 http2 push

push 允许开发者将 HTML 文件与特定资产一起推送给客户端。

传统上，客户端最初会收到 HTML 文件，并解析以确定接下来需要哪些资产，然后进一步向服务器提出请求。启用 push 后，服务器可以在客户端开始解析 HTML 之前主动推送已知需要的资产。

例如，我们有 index.html 和 style.css 两个文件，传统上浏览器会先请求 index.html，解析后再请求 style.css。既然无论如何都会请求 style.css，我们让服务器在发送 index.html 同时发送 style.css。

### 什么是 http preload

preload 允许优先下载高优先级资产。

例如，浏览器请求 index.html，在解析时发现它需要 style.css，而 css 中引用了 font.ttf 文件。与其依次请求 style.css 和 font.ttf，不如同时请求。

### 异同

preload 和 push 都是预加载的机制，区别在于：

* 语法略有不同。preload 指令可以启动 push，如果你想明确地 preload 资产而不是 push，你可以使用 nopush。

  ```http
  Link: rel=preload; </app/script.js>; as=script; nopush
  ```

* 服务器可以在收到请求后立即 push。浏览器只有在收到并解析 HTML 后才可以 preload。
* 第三方域名资产可以 preload，只能 push 自己域名的资产。
* 浏览器对 preload 的支持还不完善。push 是 HTTP2 的一个功能，有更好的支持。
* preload 允许你用 as 属性更好地定义优先级，而 push 的优先级由客户端和服务器共享。

为了更好地解释 preload 和 push 之间的区别，下图显示了顺序加载与预加载和推送资源之间的区别。

<img src="https://raw.githubusercontent.com/yamsfeer/pic-bed/master/preload%20and%20server%20push.png" alt="image-20230519175521127" style="zoom:80%;" class="img-mid" />

### 如何选用

preload 的好处是下载与执行分离。通过 onload 事件，你可以控制资源的使用细节，比如在空闲时执行 JS。

```html
<link rel="preload" href="script.js" onload="console.log('加载完成')">
```

push 可以有效缩短获取资源的时间，但是它绕过了浏览器的资源优先级逻辑，如果运用不好，反而会损害性能。

综上所述，

* 当你需要控制使用细节时，使用 preload
* 当你清楚资源的加载顺序，且有 service worker 防止缓存资源被再次推送时，使用 push。

## 延迟加载

### JavaScript

浏览器解析 HTML 时遇到 script 标签，就会暂停构建 DOM，转而下载并执行 JavaScript，执行完成后，继续处理剩余页面。也就是说，script 会阻塞 HTML 的解析过程。

将 script 放在页面底部虽然可以解决但是并不完美，浏览器只有在解析了全部 HTML 之后才会获知 script 的存在。对于的 HTML 文档来说，这会造成明显的延迟。

对此，我们需要 script 的两个属性：defer 和 async。

#### defer

defer 告诉浏览器不要等待脚本，而是继续处理 HTML，脚本会在后台下载，DOM 构建完成后，脚本才会执行。

```html
<script src="script.js" defer></script>
```

总的来说，defer 脚本有三个特性：

**defer 脚本不会阻塞页面，会在 DOM 解析完毕之后，DOMContentLoaded 之前执行。**

```html
<p>before scripts</p>

<script>
  document.addEventListener(
    'DOMContentLoaded',
    () => console.log("DOM ready after defer")
  )
</script>
<script defer src="script.js"></script>

<p>after scripts</p>
```

以上示例中，页面内容立即显示，defer 脚本下载且执行结束后触发 DOMContentLoaded 事件。

**defer 脚本之间保持相对顺序执行。**

```html
<script src="long.js" defer></script>
<script src="small.js" defer></script>
```

上面的示例中，两个脚本是并行下载的，small.js 可能会先下载完成。

defer 会确保脚本执行的相对顺序。因此，即使 small.js 先加载完成，它也会等 long.js 执行结束才会被执行。

**defer 脚本仅适用于外部脚本。**

如果 script 标签没有 src，则会忽略 defer。

#### async

async 和 defer 类似但也有不同。

- 与 defer 类似，async 脚本不阻塞页面，且只适用于外部脚本

- 其他脚本不会等待 async 脚本加载完成，async 脚本也不会等待其他脚本

- DOMContentLoaded 和 async 脚本不会彼此等待

  如果 async 脚本在页面完成后才加载完成，DOMContentLoaded 会发生在 async 脚本之前，否则在 async 之后。

总的来说，**async 脚本是在后台加载运行的完全独立的脚本**。

```html
<p>before scripts</p>

<script>
  document.addEventListener(
    'DOMContentLoaded',
    () => console.log("DOM ready")
  )
</script>
<script async src="long.js"></script>
<script async src="small.js"></script>

<p>after scripts</p>
```

以上示例中，首先，页面内容立即显示，small.js 和 long.js 谁先加载完成谁就先执行，DOMContentLoaded 事件可能在两个脚本之前或之后触发。总之，它们之间互不影响。

**独立的第三方脚本** ( 比如广告 ) 很适合 async 方式加载，这些脚本和页面的脚本互不依赖。

#### 动态脚本

动态脚本也是添加脚本的一种方式。

```javascript
const script = document.createElement('script')
script.src = "/script.js"

document.body.append(script) // 立即开始加载
```

**默认情况下，动态脚本添加的是 async 脚本。**

如果我们显式设置了 `script.async=false`，就会变成 defer 脚本，然后按照在文档中的顺序执行。

```javascript
function loadScript(src) {
  let script = document.createElement('script')
  script.src = src
  script.async = false // async 为 false，相当于 defer 脚本
  document.body.append(script)
}

loadScript("long.js")
loadScript("small.js")
```

以上示例中，long.js 总会先执行。

#### 总结

defer 和 async 都不会阻塞页面渲染。

|       |    执行顺序    |              DOMContentLoaded               |
| :---: | :------------: | :-----------------------------------------: |
| defer |   按文档顺序   | 文档解析完成之后，DOMContentLoaded 之前执行 |
| async | 先加载完先执行 |                  互不影响                   |

#### 参考

[脚本：async，defer - javascript.info](https://zh.javascript.info/script-async-defer)

### 图片

图片的延迟加载使用 `loading="lazy"` 属性，具体参考“解决方案/图片”。
