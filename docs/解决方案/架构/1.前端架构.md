# 前端架构

* 系统级，即应用在整个系统内的关系，如与后台服务如何通讯，与第三方系统如何集成。
* 应用级，即应用外部的整体架构，如多个应用之间如何共享组件、如何通信等。
* 模块级，即应用内部的模块架构，如代码的模块化、数据和状态的管理等。
* 代码级，即从基础设施来保障架构实施。

## 从需求设计架构

下面从 7 个方面来衡量一个网站，它们可以很好地描述你需要什么样的网站，从而对架构做出方向指导。

### 性能 ( Performance )

一个网站的性能可以通过 LCP、FID、CLS 等性能指标衡量。

在设计架构时，可以先进行“性能预算”。

### 可移植性 ( Portability )

* 在什么浏览器中运行？
* 在哪些设备上，以何种分辨率运行？
* 移动应用还是桌面应用？
* 是否存在限制？比如有限的带宽、对 Javascript 的支持等。

### 可靠性 ( Reliability )

* 是否需要离线使用？
* 如果后端不可用，前端应该如何反应？

### 可维护性 ( Maintainability )

* 是否在不同的前端中复用视觉组件？
* 如何快速将更改部署到生产中？
* 对故障排除有什么要求？

### 兼容性 ( Compatibility )

* 是否需要与其他前端兼容？
* 是否需要嵌入到其他环境中？ 例如 iFrame、DOM 注入、微前端等。
* 是否需要与爬虫很好地集成，例如内容预览？
* 是否需要更强的 SEO？

### 安全性 ( Security )

是否需要满足特定的安全要求？例如 [OWASP](https://owasp.org/www-project-top-ten/?ref=workingsoftware.dev) 十大安全要求？

### 可用性 ( Usability )

* 前端的交互方式是什么？内容驱动？交互驱动？
* 目标受众是什么？
* 是否需要关注可访问性问题？ [WCAG21](https://www.w3.org/WAI/WCAG21/quickref/?ref=workingsoftware.dev)

关于如何优化可访问性问题的参考 [web.dev](https://web.dev/learn/accessibility/)。

## 架构

### 客户端渲染 CSR

客户端渲染 (client-side rendering, CSR)

服务器在 SPA 中的作用主要是提供静态资产 HTML、JS 和 CSS 和 RESTful API。

![img](https://www.workingsoftware.dev/content/images/2022/12/image-23.png)



优势

* 第一个字节所需时间短
* 高度交互式网络应用程序的用户体验
* 自主前端测试
* 前端与服务器之间的松耦合
* 提供服务器端 HTTP API

缺点

* 首次内容绘制与交互时间之间可能存在较大差距
* 不适合搜索引擎优化和社交媒体预览
* 复杂性和技术异质性
* 客户端的计算资源

### 服务端渲染 SSR

Resource Oriented Client Architecture (ROCA)

使用服务器渲染技术时，前端完全在服务器端渲染

通常情况下，后台会有一个表现层或表现层。表现层或表现层包含一个模板引擎，可将动态 HTML 转换为静态 HTML。

好在由于 JavaScript 占用较少，第一次绘制内容和交互时间之间的差别不大

另一方面，由于每次页面请求都需要在服务器端完成渲染任务，因此到第一个字节的时间较长。

服务器端渲染技术支持面向资源的客户端架构（ROCA）风格。

[ROCA](https://roca-style.org/index.html?ref=workingsoftware.dev) 是一套简单的网络应用程序前端建议。

ROCA 的一些重要原则：

服务器遵循 REST。所有资源都有唯一的 URL。
通过 URL 标识的资源也可能有其他表示法（如 JSON / XML）。
所有逻辑都位于服务器上。
JavaScript 仅用于优化用户界面。
浏览器控件（如后退、前进和刷新按钮）应能正常工作。
HTML 不包含布局信息。
应用程序无需 JavaScript 即可使用。
不应在客户端和服务器上重复执行逻辑。

优势

首次绘制内容与交互时间之间的差异很小
改进性能和用户体验，因为初始 HTML 是在服务器上生成的，可以快速传送到客户端（快速交互时间）。
简化了代码库，因为所有逻辑都只在服务器上执行，没有冗余
只需发布服务器
带宽小、速度快，因为只需传输 HTML 代码
JavaScript 代码或 JS 代码传输中的错误只会导致应用程序的可用性降低，但仍可使用

缺点

到第一个字节的时间增加
难以实现具有高度交互要求的前端
浏览器缓存能力有限，因为初始 HTML 是在服务器而非客户端生成的。

### 静态资源生成 Static Site Generation ( SSG )

> A modern web development architecture is based on client-side JavaScript, reusable APIs, and pre-built markup.

JAM Stack JavaScript, reusable APIs, and pre-built markup.

这就是 JAM 堆栈的诞生，它主要通过静态页面生成（SSG）来促进静态渲染。

优势

改善性能和用户体验，因为初始 HTML 是由静态文件生成和提供的，并可被浏览器缓存（TTFB、FCP 和 TTI）。
提高安全性，因为静态文件不会受到常见的安全威胁，如 SQL 注入或跨站脚本攻击。
简化了代码库和开发工作流程，因为所有渲染都是在构建时完成的，无需服务器端语言或框架。
提高了可扩展性和可靠性，因为静态文件可以很容易地从全球内容交付网络（CDN）分发和提供。
缺点

对复杂或动态内容的支持有限（不灵活），因为内容必须预先生成，不能实时更新。
开发和维护成本增加，因为 SSG 需要额外的工具和流程来生成和管理静态内容。
导致客户端/水合

### 预渲染 Pre-Rendering

在这种情况下，您会在构建时运行单页应用程序，将其初始状态捕获为静态 HTML。在第一次调用时，将其作为静态 HTML 发送。

优势

改进性能和用户体验，因为初始 HTML 是在客户端生成的，可被浏览器缓存（TTFB、FCP）。
改善搜索引擎优化，因为搜索引擎可以抓取并索引在客户端生成的初始 HTML。
简化代码库，因为所有渲染都在客户端完成，无需管理服务器端渲染。
提高了灵活性，可以在初始预渲染过程完成之前在客户端执行某些操作或访问某些信息。
减少服务器负载和潜在的性能问题，因为渲染是在客户端而不是服务器上进行的。
缺点

预渲染复杂或动态内容的能力有限，因为初始 HTML 必须在服务器上生成。
开发和维护成本增加，因为预渲染需要额外的工具和流程。

### 同构渲染 Isomorphic

在这种情况下，每次导航变化（即 HTTP 请求）都会导致单页应用程序的服务器端渲染。

预先渲染的页面将作为 HTTP 响应返回前端，然后在客户端再次启动网络应用程序。

因此，网络应用程序将从交互性不强过渡到完全交互。

优势

提高前端页面的性能和渲染速度（良好的 FCP）
更好的搜索引擎优化，改进动态内容的搜索引擎索引，改进社交媒体帖子的预览生成
可预先渲染页面，改善网络连接速度较慢用户的用户体验
提高安全性，防止跨站脚本攻击
支持速度较慢的网络连接
缺点

由于需要管理服务器端和客户端渲染，代码库的复杂性增加。
由于在服务器上渲染（FCP 和 TTI 之间的延迟），增加了服务器负载和潜在的性能问题。
浏览器缓存功能有限，因为初始 HTML 是在服务器而非客户端生成的。
潜在的搜索引擎优化挑战，因为搜索引擎可能无法抓取和索引客户端生成的动态内容。
在初始水合过程完成之前，客户端执行某些操作或访问某些信息的能力有限。

## 参考

[Which web frontend architecture fits best?](https://www.workingsoftware.dev/frontend-rendering-techniques/), workingsoftware.dev

