# 微前端

微前端 ( Micro-frontend )

## 问题

* 如何组合微应用：基座模式，容器

* 路由：基座拦截路由，容器使用 browser history，微应用使用 memory history
* 微应用间通信：通过基座作为中间人通信、通过全局对象如 window
* 应用间模块共享？版本不匹配

1. 因为拆分打包，所以有了更小的加载体积，而且当前子系统已经下载的chunk可以被共享，如果可以复用，下一个子系统将不会再次下载。这也就具备了可以在项目运行时同步更新不同项目间的同一模块逻辑依赖且节约了代码构建成本，维护成本等。
2. 相比过去， externals 无法多版本共存，dll 无法共享模块，MF 完美解决。
3. 借助运行时动态加载模块的特性，可以做到更好的A/B test
4. MF 可以和服务端渲染结合使用，也与 [CDN](https://cloud.tencent.com/product/cdn?from_column=20421&from=20421) 的[边缘计算](https://cloud.tencent.com/product/edgezone?from_column=20421&from=20421)契合的很好，畅想一下，它还能结合 serverless 做按需编译的加载。



### **MF在微前端应用上的对比**

Module Federation 和 qiankun/icestark 等框架在微前端应用上的一些差别：

1. 微的定义 MF 基于 `模块`，qiankun/icestark 等框架基于 `应用`，也就是说MF是由多个互相独立的模块聚合而成的应用，框架是由多个互相独立的应用聚合而成的应用。
2. 技术实现 MF 模块本质上是`JS代码片段`，这种代码片段一般称为chunk。因此，模块的聚合，实际上是chunk的聚合。框架应用本质上是`HTML`，而在SPA中，HTML又是main.js进行填充的。因此，应用的聚合，实际上是main.js的聚合。
3. 使用场景 MF 是一种技术升级的创造性工作，有一定成本，目的是为了让系统具备更强大的能力。框架是一种维持现状的保守性工作，成本极小，目的是为了让系统拥有更长久的生命力。
4. 案例体现 由YY业务中台web前端组团队自主研发的EMP微前端方案就是基于 MF 的能力而实现的。项目地址：https://github.com/efoxTeam/emp qiankun 框架可以直接看官网，地址：https://qiankun.umijs.org/zh/guide/tutorial

两者只不过微的粒度以及使用场景不同罢了，都可以成为微前端。

### **MF的缺点**

1. 对环境要求略高，需要使用webpack5，旧项目改造成本大。
2. 对代码封闭性高的项目，依旧需要做npm那一套管理和额外的拉取代码，还不如npm复用方便。
3. 拆分粒度需要权衡,虽然能做到依赖共享，但是被共享的lib不能做tree-shaking，也就是说如果共享了一个lodash，那么整个lodash库都会被打包到shared-chunk中。虽然依赖共享能解决传统微前端的externals的版本一致性问题。
4. webpack为了支持加载remote模块对runtime做了大量改造，在运行时要做的事情也因此陡然增加，可能会对我们页面的运行时性能造成负面影响。
5. 运行时共享也是一把双刃剑，如何去做版本控制以及控制共享模块的影响是需要去考虑的问题。
6. 远程模块 typing 的问题。







## single-spa

## qiankun

## module federation

