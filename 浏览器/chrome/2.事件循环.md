# 事件循环 ( Event Loop )

> 【摘要】

由于主线程过于繁忙，引发了任务调度的问题。主线程的任务调度就是排队。

为什么无法用多线程处理？因为任务之间不是独立的。

## 事件循环模型



### 异步

由于渲染主线程是单线程的，为了避免阻塞，提出了异步的解决办法，即事件循环模型。

单线程是异步产生的原因，事件循环是异步的实现方式



这里可以联想到一个完整的任务调度模型，在现实中可类比为银行排队，如果其中一个人缺少材料，则让这个人到旁边处理完毕，然后重新排队。

银行窗口可以有多个，但渲染主线程这个语境下，相当于只有一个窗口，即单线程。

### 事件循环队列

事件循环队列中的任务是由回调函数包装而成的，它是一个任务对象。



### 例子

```javascript
var h1 = document.querySelector('h1')
var btn = document.querySelector('button')

function delay(duration) {
  var start = Date.now();
  while (Date.now() - start < duration) {}
}

btn.onclick = function () {
  h1.textContent = '袁老师很帅!' // 立即生效，将重新渲染任务入队
  delay(3000) // 阻塞重新渲染
}
```





## 任务队列的类型及优先级

每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型 的任务可以分属于不同的队列。 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执 行。 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行

```
    https://html.spec.whatwg.org/multipage/webappapis.html#p
    erform-a-microtask-checkpoint
```

随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法。

* 延时队列:用于存放计时器到达后的回调任务，优先级「中」
* 交互队列:用于存放用户操作后产生的事件处理任务，优先级「高」
* 微队列:用户存放需要最快执行的任务，优先级「最高」
* 。。。

chrome 认为交互更重要，因此，交互队列的优先级要高于延时队列



## 微任务队列

添加任务到微队列的主要方式主要是使用 Promise、MutationObserver、queueMicroTask